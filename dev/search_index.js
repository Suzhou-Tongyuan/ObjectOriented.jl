var documenterSearchIndex = {"docs":
[{"location":"cheat-sheet-cn/#TyOOP-Cheat-Sheet","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"TyOOP为Julia提供面向对象编程的功能，支持多继承、点操作符取成员、Python风格的properties以及接口编程。","category":"page"},{"location":"cheat-sheet-cn/#.-类型定义","page":"TyOOP Cheat Sheet","title":"1. 类型定义","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"定义不可变的OO结构体。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@oodef struct ImmutableData\r\n    x :: Int\r\n    y :: Int\r\n\r\n    function new(x::Int, y::Int) \r\n        @mk begin\r\n            x = x\r\n            y = y\r\n        end\r\n    end\r\nend\r\n\r\nd = ImmutableData(1, 2)\r\nx = d.x","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"其中，new是构造器函数。构造器和方法都可以重载。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@mk语句块产生当前类型的实例，在随后的语句块中，形如a = b是设置字段，形如BaseClass(arg1, arg2)是基类初始化。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"定义可变的OO结构体（class）。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@oodef mutable struct MutableData\r\n    x :: Int\r\n    y :: Int\r\n\r\n    function new(x::Int, y::Int) \r\n        @mk begin\r\n            x = x\r\n            y = y\r\n        end\r\n    end\r\nend\r\n\r\nmt = MutableData(1, 2)\r\nmt.x += 1","category":"page"},{"location":"cheat-sheet-cn/#默认字段","page":"TyOOP Cheat Sheet","title":"默认字段","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"TyOOP支持默认字段。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"在为类型定义一个字段时，如果为这个字段指定默认值，那么@mk宏允许缺省该字段的初始化。注意，如果不定义new函数并使用@mk宏，默认字段将无效。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"function get_default_field2()\r\n    println(\"default field2!\")\r\n    return 30\r\nend\r\n\r\n@oodef struct MyType\r\n    field1 :: DataType = MyType\r\n    field2 :: Int = get_default_field2()\r\n\r\n    function new()\r\n        return @mk\r\n    end\r\n\r\n    function new(field2::Integer)\r\n        return @mk field2 = field2\r\n    end\r\nend\r\n\r\njulia> MyType()\r\ndefault field2!\r\nMyType(MyType, 30)\r\n\r\njulia> MyType(50)\r\nMyType(MyType, 50)","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"关于默认字段的注意点：","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"默认字段没有性能开销。\n在@mk块显式指定字段初始化时，默认字段的求值表达式不会被执行。\n与Base.@kwdef不同，默认字段的求值表达式无法访问其他字段。","category":"page"},{"location":"cheat-sheet-cn/#.-继承","page":"TyOOP Cheat Sheet","title":"2. 继承","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@oodef mutable struct Animal\r\n    name :: String\r\n    function new(theName::String)\r\n        @mk begin\r\n            name = theName\r\n        end\r\n    end\r\n\r\n    function move(self, distanceInMeters::Number = 0)\r\n        println(\"$(self.name) moved $(distanceInMeters)\")\r\n    end\r\nend\r\n\r\n@oodef mutable struct Snake <: Animal\r\n    function new(theName::String)\r\n        @mk begin\r\n            Animal(theName) # 初始化基类\r\n        end\r\n    end\r\n\r\n    function snake_check(self)\r\n        println(\"Calling a snake specific method!\")\r\n    end\r\nend\r\n\r\nsam = Snake(\"Sammy the Python\")\r\nsam.move()\r\n# Sammy the Python moved 0\r\nsam.snake_check()\r\n# Calling a snake specific method!","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"此外，以下需要非常注意！","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"Snake <: Animal # false\r\nSnake(\"xxx\") isa Animal # false","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"记住，Julia原生类型系统并不理解两个class的子类型关系！详见基于接口的多态抽象。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"你应该使用下列方法测试继承关系：","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"issubclass(Snake, Animal) # true\r\nisinstance(Snake(\"xxx\"), Animal) # true\r\nSnake(\"xxx\") isa @like(Animal) # true","category":"page"},{"location":"cheat-sheet-cn/#.-Python-style-properties","page":"TyOOP Cheat Sheet","title":"4. Python-style properties","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@oodef mutable struct Square\r\n    side :: Float64\r\n\r\n    @property(area) do\r\n        get = self -> self.side ^ 2\r\n        set = (self, value::Number) -> self.side = convert(Float64, sqrt(value))\r\n    end\r\nend\r\n\r\nsquare = Square()\r\nsquare.side = 10\r\n# call getter\r\nsquare.area # 100.0\r\n\r\n# call setter\r\nsquare.area = 25\r\nsquare.side # 5.0","category":"page"},{"location":"cheat-sheet-cn/#.-接口","page":"TyOOP Cheat Sheet","title":"5. 接口","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"接口类型，是大小为0(sizeof(t) == 0)的不可变OO类型。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"接口类型的构造器是自动生成的，但也可以手动定义。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"下面的HasLength是接口类型。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@oodef struct HasLength\r\n    @property(len) do\r\n        get  #= 抽象property: len =#\r\n    end\r\nend\r\n\r\n@oodef struct Fillable\r\n    function fill! end # 空函数表示抽象方法\r\n\r\n    # 定义一个抽象的setter, 可以为全体元素赋值\r\n    @property(allvalue) do\r\n        set\r\n    end\r\nend\r\n\r\n@oodef struct MyVector{T} <: {HasLength, Fillable}  # 多继承\r\n    xs :: Vector{T}\r\n    function new(xs::Vector{T})\r\n        @mk begin\r\n            xs = xs\r\n        end\r\n    end\r\nend\r\n\r\ncheck_abstract(MyVector)\r\n# Dict{PropertyName, TyOOP.CompileTime.PropertyDefinition} with 3 entries:\r\n#   fill! (getter)    => PropertyDefinition(:fill!, missing, :((Main).Fillable), MethodKind)\r\n#   len (getter)      => PropertyDefinition(:len, missing, :((Main).HasLength), GetterPropertyKind)\r\n#   allvalue (setter) => PropertyDefinition(:allvalue, missing, :((Main).Fillable), SetterPropertyKind)","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"check_abstract(MyVector)不为空，表示MyVector是抽象类型，否则需要实现相应属性或方法len, fill!和allvalue：","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@oodef struct MyVector{T} <: {HasLength, Fillable}  # 多继承\r\n    # 旧代码\r\n    xs :: Vector{T}\r\n    function new(xs::Vector{T})\r\n        @mk begin\r\n            xs = xs\r\n        end\r\n    end\r\n\r\n    # 新增代码\r\n    @property(len) do\r\n        get = self -> length(self.xs)\r\n    end\r\n\r\n    @property(allvalue) do\r\n        set = (self, value::T) -> fill!(self.xs, value)\r\n    end\r\n\r\n    function fill!(self, v::T)\r\n        self.allvalue = v\r\n    end\r\nend\r\n\r\nvec = MyVector([1, 2, 3])\r\nvec.allvalue = 4\r\nvec\r\n# MyVector{Int64}([4, 4, 4], HasLength(), Fillable())\r\nvec.len\r\n# 3\r\nvec.fill!(10)\r\nvec\r\n# MyVector{Int64}([10, 10, 10], HasLength(), Fillable())","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"此外，接口最重要的目的是基于接口的多态抽象。见下文基于接口的多态抽象。","category":"page"},{"location":"cheat-sheet-cn/#.-多继承","page":"TyOOP Cheat Sheet","title":"6. 多继承","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"MRO(方法解析顺序)使用Python C3算法，所以多继承行为与Python基本一样。主要差异是不严格要求mixin多继承的顺序。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@oodef struct A\r\n    function calla(self) \"A\" end\r\n    function call(self) \"A\" end\r\nend\r\n\r\n@oodef struct B <: A\r\n    function callb(self) \"B\" end\r\n    function call(self) \"B\" end\r\nend\r\n\r\n@oodef mutable struct C <: A\r\n    function callc(self) \"C\" end\r\n    function call(self) \"C\" end\r\nend\r\n\r\n@oodef struct D <: {A, C, B}\r\n    function new()\r\n        @mk begin\r\n            A() # 可省略，因为A是接口类型\r\n            B() # 可省略，因为B是接口类型\r\n            C() # 不可省略，因为C是可变类型\r\n            # 基类初始化可写成一行: A(), B(), C()\r\n        end\r\n    end\r\nend\r\n\r\nd = D()\r\nd.calla() # A\r\nd.callb() # B\r\nd.callc() # C\r\nd.call() # C\r\n[x[1] for x in ootype_mro(typeof(d))]\r\n# 4-element Vector{DataType}:\r\n#  D\r\n#  C\r\n#  B\r\n#  A","category":"page"},{"location":"cheat-sheet-cn/#.-[基于接口的多态抽象](@id-interface_polymorphism)","page":"TyOOP Cheat Sheet","title":"7. 基于接口的多态抽象","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"下面例子给出一个容易犯错的情况：","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@oodef struct A end\r\n@oodef struct B <: A end\r\nmyapi(x :: A) = println(\"do something!\")\r\n\r\nmyapi(A())\r\n# do something!\r\n\r\nmyapi(B())\r\n# ERROR: MethodError: no method matching myapi(::B)","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"记住：Julia原生类型系统并不理解两个class的子类型关系！","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"如果希望Julia函数myapi的参数只接受A或A的子类型，应该这样实现：","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"myapi(x :: @like(A)) = println(\"do something!\")\r\n\r\nmyapi(B())\r\n# do something!\r\n\r\nmyapi([])\r\n# ERROR: MethodError: no method matching myapi(::Vector{Any})","category":"page"},{"location":"cheat-sheet-cn/#.-一个机器学习的OOP实例","page":"TyOOP Cheat Sheet","title":"8. 一个机器学习的OOP实例","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"在下面这份代码里，我们实现一个使用最小二乘法训练的机器学习模型，并让其支持Julia中ScikitLearn的接口 (ScikitLearnBase.jl)。通过下面代码，用户可以像使用一般ScikitLearn.jl的模型一样来调用这个模型，更可以在MLJ机器学习框架中使用这个模型，而不必关心该模型由面向对象还是多重分派实现。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"using TyOOP\r\n\r\n@oodef struct AbstractMLModel{X, Y}\r\n    function fit! end\r\n    function predict end\r\nend\r\n\r\nusing LsqFit\r\n\r\n@oodef mutable struct LsqModel{M<:Function} <: AbstractMLModel{Vector{Float64},Vector{Float64}}\r\n    model::M  # 一个函数，代表模型的公式\r\n    param::Vector{Float64}\r\n\r\n    function new(m::M, init_param::Vector{Float64})\r\n        @mk begin\r\n            model = m\r\n            param = init_param\r\n        end\r\n    end\r\n\r\n    function fit!(self, X::Vector{Float64}, y::Vector{Float64})\r\n        fit = curve_fit(self.model, X, y, self.param)\r\n        self.param = fit.param\r\n        self\r\n    end\r\n\r\n    function predict(self, x::Float64)\r\n        self.predict([x])\r\n    end\r\n\r\n    function predict(self, X::Vector{Float64})\r\n        return self.model(X, self.param)\r\n    end\r\nend\r\n\r\n# 例子来自 https://github.com/JuliaNLSolvers/LsqFit.jl\r\n\r\n@. model(x, p) = p[1] * exp(-x * p[2])\r\nclf = LsqModel(model, [0.5, 0.5])\r\nptrue = [1.0, 2.0]\r\nxdata = collect(range(0, stop = 10, length = 20));\r\nydata = collect(model(xdata, ptrue) + 0.01 * randn(length(xdata)));\r\n\r\nclf.fit!(xdata, ydata) # 训练模型\r\nclf.predict(xdata)  # 预测模型\r\nclf.param # 查看模型参数\r\n\r\n# ScikitLearnBase提供了fit!和predict两个接口函数。\r\n# 我们将TyOOP的接口(@like(...))和Julia接口对接。\r\n\r\nusing ScikitLearnBase\r\nScikitLearnBase.is_classifier(::@like(AbstractMLModel)) = true\r\nScikitLearnBase.fit!(clf::@like(AbstractMLModel{X, Y}), x::X, y::Y) where {X, Y} = clf.fit!(x, y)\r\nScikitLearnBase.predict(clf::@like(AbstractMLModel{X}), x::X) where X = clf.predict(x)\r\n\r\nScikitLearnBase.fit!(clf, xdata, ydata)\r\nScikitLearnBase.predict(clf, xdata)","category":"page"},{"location":"cheat-sheet-cn/#.-性能问题","page":"TyOOP Cheat Sheet","title":"9. 性能问题","text":"","category":"section"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"TyOOP生成的代码本身不引入开销，但由于递归调用点操作符运算 (Base.getproperty(...)) 的类型推断问题 (例如这个例子)，尽管大多数时候TyOOP编译出的机器码非常高效，但返回类型却忽然变成Any或某种Union类型。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"这可能带来性能问题。出现该问题的情况是有限的，问题场合如下：","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"使用Python风格的property\n在method里访问另一个成员，该成员再次递归调用点操作符","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"解决方案也很简单，使用@typed_access标注可能出现性能问题的代码即可。","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"@typed_access my_instance.method()\r\n@typed_access my_instance.property","category":"page"},{"location":"cheat-sheet-cn/","page":"TyOOP Cheat Sheet","title":"TyOOP Cheat Sheet","text":"注意：上述代码中请保证my_instance类型已知。如果@typed_access标注的代码存在动态类型或类型不稳定，可能导致更严重的性能问题。","category":"page"},{"location":"cheat-sheet-en/#TyOOP-cheat-sheet","page":"Cheat Sheet","title":"TyOOP cheat sheet","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"中文文档","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"TyOOP has provided relatively complete object-oriented programming support for Julia. It supports multiple inheritances, dot-operator access to members, Python-style properties and interface proramming.","category":"page"},{"location":"cheat-sheet-en/#.-Type-definition","page":"Cheat Sheet","title":"1. Type definition","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Define immutable OO structs:","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct ImmutableData\r\n    x :: Int\r\n    y :: Int\r\n\r\n    function new(x::Int, y::Int) \r\n        @mk begin\r\n            x = x\r\n            y = y\r\n        end\r\n    end\r\nend\r\n\r\nd = ImmutableData(1, 2)\r\nx = d.x","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"newis the constructor. Constructs and methods can be overloaded.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"A @mk block creates an instance for the current struct/class. Inside the block, an assignment statement a = b initializes the field a with the expression b; a call statement like BaseType(arg1, arg2) calls the constructor of the base class/struct BaseType.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Defining OO classes (mutable structs):","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef mutable struct MutableData\r\n    x :: Int\r\n    y :: Int\r\n\r\n    function new(x::Int, y::Int) \r\n        @mk begin\r\n            x = x\r\n            y = y\r\n        end\r\n    end\r\nend\r\n\r\nmt = MutableData(1, 2)\r\nmt.x += 1","category":"page"},{"location":"cheat-sheet-en/#Default-field-values","page":"Cheat Sheet","title":"Default field values","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Using this feature, when defining a field for classes/structs, if a default value is provided, then the initialization for this field can be missing in the @mk block.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"function get_default_field2()\r\n    println(\"default field2!\")\r\n    return 30\r\nend\r\n\r\n@oodef struct MyType\r\n    field1 :: DataType = MyType\r\n    field2 :: Int = get_default_field2()\r\n\r\n    function new()\r\n        return @mk\r\n    end\r\n\r\n    function new(field2::Integer)\r\n        return @mk field2 = field2\r\n    end\r\nend\r\n\r\njulia> MyType()\r\ndefault field2!\r\nMyType(MyType, 30)\r\n\r\njulia> MyType(50)\r\nMyType(MyType, 50)","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Some points of the default field values:","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"there is no performance overhead in using default field values.\nwhen a field has been explicitly initialized in the @mk block, the expression of the default field value won't be evaluated.\nunlike Base.@kwdef, default field values cannot reference each other.","category":"page"},{"location":"cheat-sheet-en/#.-Inheritance","page":"Cheat Sheet","title":"2. Inheritance","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef mutable struct Animal\r\n    name :: String\r\n    function new(theName::String)\r\n        @mk begin\r\n            name = theName\r\n        end\r\n    end\r\n\r\n    function move(self, distanceInMeters::Number = 0)\r\n        println(\"$(self.name) moved $(distanceInMeters)\")\r\n    end\r\nend\r\n\r\n@oodef mutable struct Snake <: Animal\r\n    function new(theName::String)\r\n        @mk begin\r\n            Animal(theName) # 初始化基类\r\n        end\r\n    end\r\n\r\n    function snake_check(self)\r\n        println(\"Calling a snake specific method!\")\r\n    end\r\nend\r\n\r\nsam = Snake(\"Sammy the Python\")\r\nsam.move()\r\n# Sammy the Python moved 0\r\nsam.snake_check()\r\n# Calling a snake specific method!","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"CAUTION:","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Snake <: Animal # false\r\nSnake(\"xxx\") isa Animal # false","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Note that Julia's native type system does not understand the subtyping relationship between two oo classes! See Interface-based polymorphism for more details.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Use the following methods to test inheritance relationship:","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"issubclass(Snake, Animal) # true\r\nisinstance(Snake(\"xxx\"), Animal) # true\r\nSnake(\"xxx\") isa @like(Animal) # true","category":"page"},{"location":"cheat-sheet-en/#.-Python-style-properties","page":"Cheat Sheet","title":"4. Python-style properties","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef mutable struct Square\r\n    side :: Float64\r\n\r\n    @property(area) do\r\n        get = self -> self.side ^ 2\r\n        set = (self, value::Number) -> self.side = convert(Float64, sqrt(value))\r\n    end\r\nend\r\n\r\nsquare = Square()\r\nsquare.side = 10\r\n# call getter\r\nsquare.area # 100.0\r\n\r\n# call setter\r\nsquare.area = 25\r\nsquare.side # 5.0","category":"page"},{"location":"cheat-sheet-en/#.-Interfaces","page":"Cheat Sheet","title":"5. Interfaces","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"An interface in TyOOP means an OO struct type which satisfies sizeof(interface) == 0.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Interface constructors are auto-generated, but custom constructors are allowed.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"The following HasLength is an interface.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct HasLength\r\n    @property(len) do\r\n        get  # abstract getter property\r\n    end\r\nend\r\n\r\n@oodef struct Fillable\r\n    function fill! end # an empty function means abstract method\r\n\r\n    # define an abstract property  to set all values\r\n    @property(allvalue) do\r\n        set\r\n    end\r\nend\r\n\r\n@oodef struct MyVector{T} <: {HasLength, Fillable}  # multiple inheritance\r\n    xs :: Vector{T}\r\n    function new(xs::Vector{T})\r\n        @mk begin\r\n            xs = xs\r\n        end\r\n    end\r\nend\r\n\r\ncheck_abstract(MyVector)\r\n# Dict{PropertyName, TyOOP.CompileTime.PropertyDefinition} with 3 entries:\r\n#   fill! (getter)    => PropertyDefinition(:fill!, missing, :((Main).Fillable), MethodKind)\r\n#   len (getter)      => PropertyDefinition(:len, missing, :((Main).HasLength), GetterPropertyKind)\r\n#   allvalue (setter) => PropertyDefinition(:allvalue, missing, :((Main).Fillable), SetterPropertyKind)","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"check_abstract(MyVector) is not empty. This means MyVector is abstract (more accurately, shall not be instantiated). Otherwise, implementing len, fill!和allvalue is required.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct MyVector{T} <: {HasLength, Fillable}  # multiple inheritance\r\n    xs :: Vector{T}\r\n    function new(xs::Vector{T})\r\n        @mk begin\r\n            xs = xs\r\n        end\r\n    end\r\n\r\n    # add the following definitions to \r\n    # implement `HasLength` and `Fillable`\r\n    @property(len) do\r\n        get = self -> length(self.xs)\r\n    end\r\n\r\n    @property(allvalue) do\r\n        set = (self, value::T) -> fill!(self.xs, value)\r\n    end\r\n\r\n    function fill!(self, v::T)\r\n        self.allvalue = v\r\n    end\r\nend\r\n\r\nvec = MyVector([1, 2, 3])\r\nvec.allvalue = 4\r\nvec\r\n# MyVector{Int64}([4, 4, 4], HasLength(), Fillable())\r\nvec.len\r\n# 3\r\nvec.fill!(10)\r\nvec\r\n# MyVector{Int64}([10, 10, 10], HasLength(), Fillable())","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"In addition, the most important reason for interfaces is the interface-based polymorphism. See Interface-based polymorphism.","category":"page"},{"location":"cheat-sheet-en/#.-Multiple-inheritance","page":"Cheat Sheet","title":"6. Multiple inheritance","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"MRO (Method resolution order) is using Python's C3 algorithm, so the behaviour is mostly identical to Python. The major difference is that the order of inheriting mixin classes is less strict.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct A\r\n    function calla(self) \"A\" end\r\n    function call(self) \"A\" end\r\nend\r\n\r\n@oodef struct B <: A\r\n    function callb(self) \"B\" end\r\n    function call(self) \"B\" end\r\nend\r\n\r\n@oodef mutable struct C <: A\r\n    function callc(self) \"C\" end\r\n    function call(self) \"C\" end\r\nend\r\n\r\n@oodef struct D <: {A, C, B}\r\n    function new()\r\n        @mk begin\r\n            A() # can omit. A is interface.\r\n            B() # can omit. B is interface.\r\n            C() # cannot omit. C is class (mutable struct).\r\n            # you can also write them in one line:\r\n            # A(), B(), C()\r\n        end\r\n    end\r\nend\r\n\r\nd = D()\r\nd.calla() # A\r\nd.callb() # B\r\nd.callc() # C\r\nd.call() # C\r\n[x[1] for x in ootype_mro(typeof(d))]\r\n# 4-element Vector{DataType}:\r\n#  D\r\n#  C\r\n#  B\r\n#  A","category":"page"},{"location":"cheat-sheet-en/#.-[Interface-based-polymorphism](@id-interface_polymorphism_cn)","page":"Cheat Sheet","title":"7. Interface-based polymorphism","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"The following example shows an inproper use of the base class (A):","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@oodef struct A end\r\n@oodef struct B <: A end\r\nmyapi(x :: A) = println(\"do something!\")\r\n\r\nmyapi(A())\r\n# do something!\r\n\r\nmyapi(B())\r\n# ERROR: MethodError: no method matching myapi(::B)","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Remember that Julia's type system does not understand the subtyping relationship between two OO classes!","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"If you expect myapi  to accept A or A's subtypes, you should do this:","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"myapi(x :: @like(A)) = println(\"do something!\")\r\n\r\nmyapi(B())\r\n# do something!\r\n\r\nmyapi([])\r\n# ERROR: MethodError: no method matching myapi(::Vector{Any})","category":"page"},{"location":"cheat-sheet-en/#.-A-machine-learning-example","page":"Cheat Sheet","title":"8. A machine learning example","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"In the following code, we implement a machine learning model trained using least squares and make it support the ScikitLearn interface (ScikitLearnBase.jl) in Julia. With the following code, users can call this model as if it were a normal ScikitLearn.jl model, and can use this model in the MLJ machine learning framework, regardless of whether the model is implemented by object-oriented features or multiple dispatch.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"using TyOOP\r\n\r\n@oodef struct AbstractMLModel{X, Y}\r\n    function fit! end\r\n    function predict end\r\nend\r\n\r\nusing LsqFit\r\n\r\n@oodef mutable struct LsqModel{M<:Function} <: AbstractMLModel{Vector{Float64},Vector{Float64}}\r\n    model :: M  # a function to represent the model's formula\r\n    param :: Vector{Float64}\r\n\r\n    function new(m::M, init_param::Vector{Float64})\r\n        @mk begin\r\n            model = m\r\n            param = init_param\r\n        end\r\n    end\r\n\r\n    function fit!(self, X::Vector{Float64}, y::Vector{Float64})\r\n        fit = curve_fit(self.model, X, y, self.param)\r\n        self.param = fit.param\r\n        self\r\n    end\r\n\r\n    function predict(self, x::Float64)\r\n        self.predict([x])\r\n    end\r\n\r\n    function predict(self, X::Vector{Float64})\r\n        return self.model(X, self.param)\r\n    end\r\nend\r\n\r\n# the example comes from https://github.com/JuliaNLSolvers/LsqFit.jl\r\n\r\n@. model(x, p) = p[1] * exp(-x * p[2])\r\nclf = LsqModel(model, [0.5, 0.5])\r\nptrue = [1.0, 2.0]\r\nxdata = collect(range(0, stop = 10, length = 20));\r\nydata = collect(model(xdata, ptrue) + 0.01 * randn(length(xdata)));\r\n\r\nclf.fit!(xdata, ydata) # train\r\nclf.predict(xdata)     # predict\r\nclf.param              # inspect model parameters\r\n\r\n# ScikitLearnBase provides us two interface functions 'fit!' and 'predict'.\r\n# Now, we connect the TyOOP interface with Julia's idiomatic interface\r\n# via '@like(...)'.\r\n\r\nusing ScikitLearnBase\r\nScikitLearnBase.is_classifier(::@like(AbstractMLModel)) = true\r\nScikitLearnBase.fit!(clf::@like(AbstractMLModel{X, Y}), x::X, y::Y) where {X, Y} = clf.fit!(x, y)\r\nScikitLearnBase.predict(clf::@like(AbstractMLModel{X}), x::X) where X = clf.predict(x)\r\n\r\nScikitLearnBase.fit!(clf, xdata, ydata)\r\nScikitLearnBase.predict(clf, xdata)","category":"page"},{"location":"cheat-sheet-en/#.-Performance-issues","page":"Cheat Sheet","title":"9. Performance issues","text":"","category":"section"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Code generated by TyOOP does not introduce any overhead, but recursions of dot operations (Base.getproperty(...)) do have some issues concerning type inference (e.g., this example). Although in most cases, the code produced by TyOOP is very efficient, the return type might suddenly becomes Any or some Union type.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"This might cause performance issues, but only in enumerable cases that have been well understood:","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"Using Python-style properties\nVisiting another member in methods, the member will recursively perform dot operations (Base.getproperty).","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"The solution is easy: use @typed_access to wrap a block of code which might suffer from above issues.","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"@typed_access my_instance.method()\r\n@typed_access my_instance.property","category":"page"},{"location":"cheat-sheet-en/","page":"Cheat Sheet","title":"Cheat Sheet","text":"CAUTION: please make sure that the type of the above my_instance is inferred when using @typed_access. Using @typed_acccess in dynamic code will damage your performance.","category":"page"},{"location":"how-to-translate-oop-into-julia/#Translating-OOP-into-Idiomatic-Julia","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Multiple dispatch used by Julia gives a novel solution to the expression problem, while the so-called object-oriented programming has a different answer that is much more popular.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Although we'd admit that there are some essential differences between OOP and multiple dispatch under the hood, they are not that different. In fact, Julia's multiple dispatch definitely steps further and can fully express OOP, although certain translation (very rare) is so far never efficient (I mean, fast in execution time).","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"This article aims at telling people how to translate serious OOP code into idiomatic Julia. The translation is divided into the following sections:","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Julia representation of constructors\nJulia representation of methods\nJulia representation of inheritance\nJulia representation of interfaces","category":"page"},{"location":"how-to-translate-oop-into-julia/#Julia-representation-of-constructors","page":"Translating OOP into Idiomatic Julia","title":"Julia representation of constructors","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"In Python, we might simply write a class as follow.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"class MyClass:\r\n    def __init__(self, a):\r\n        self.a = a\r\n        self.b = a + a\r\n\r\nMyClass(1)","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Python encapsulates instantiation and the instance initialization into a single call MyClass(1), but if we dig a little deeper, we will know that the construction of a Python object works like this:","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"inst = MyClass.__new__(MyClass, 1)\r\nif isinstance(inst, MyClass):\r\n    MyClass.__init__(inst, 1)\r\nreturn inst","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"We have found a fresh Julia user who comes from the OOP world can be anxious about the constructor. In Julia, a struct provides a default constructor which takes arguments in order of the class fields. This asks Julia users to create an instance (like __new__()) manually, but OOP guys would rather only create instance initialization function (like __init__()) themselves.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"struct MyClass\r\n    a\r\n    b\r\nend\r\n\r\nb = a + a\r\nMyClass(a, b)","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"However, achieving what OOP guys need is convenient and even mechanical. \"Convenient\" means Julia can do the same thing in a way less verbose than others, and \"mechanical\" means this is a general solution to the problem, and the problem is well-studied in the used mechanism.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"We post the solution as follow. For readability, the code is simplified and the functionality is incomplete in corner cases.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"The solution has 2 parts, the first one is the library code which is not very readable, but it is not responsible for users to implement; the second part is the user code, it is readable and concise, exactly like what in Python.","category":"page"},{"location":"how-to-translate-oop-into-julia/#lib_constructor","page":"Translating OOP into Idiomatic Julia","title":"Library code","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"## `new` and `init` can be overloaded for different classes\r\n@generated function default_constructor(::Type{Cls}) where Cls\r\n    Expr(:new, Cls)\r\nend\r\n\r\nfunction new(cls, args...; kwargs...)\r\n    # call default constructor without field initialization\r\n    return default_constructor(cls)\r\nend\r\n\r\nfunction init(self, args...; kwargs...)\r\n    nothing\r\nend\r\n\r\nabstract type OO end\r\n\r\nfunction (::Type{Cls})(args...; kwargs...) where Cls <: OO\r\n    inst = new(Cls, args...; kwargs...)\r\n    if inst isa Cls\r\n        init(inst, args...; kwargs...)\r\n    end\r\n    return inst\r\nend","category":"page"},{"location":"how-to-translate-oop-into-julia/#User-code","page":"Translating OOP into Idiomatic Julia","title":"User code","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"mutable struct MyClass <: OO\r\n    a\r\n    b\r\nend\r\n\r\nfunction init(self::MyClass, a)\r\n    self.a = a\r\n    self.b = a + a\r\nend\r\n\r\nMyClass(1)","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"If we mark the functions new, init or (::Type{Cls}) with @inline, the code becomes as efficient as in C/C++.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"However, Julia does not adopt this solution. There are many reasons, but the key one is that Julia has native support for immutability. Mutable classes can be created without initializing fields but modified later, while immutable structs never support this. ","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"struct Data\r\n    a :: Int\r\nend\r\ndata = Data(1)\r\ndata.a = 2\r\n\r\nERROR: setfield!: immutable struct of type Data cannot be changed","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"The old and popular approach to object construction, like Python's __init__, works in the old world, but using it for a language providing new features (like immutability) is not deemed a good idea. The old solution can be provided as a library, but it discourages the use of the good features such as immutability.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"TyOOP provides the new function and @mk macro to address above issue. Using new and @mk, your code is slightly more concise than in Python, and works for both mutable structs and immutable structs.","category":"page"},{"location":"how-to-translate-oop-into-julia/#Julia-representation-of-methods","page":"Translating OOP into Idiomatic Julia","title":"Julia representation of methods","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"In Python, we can define methods for a class so that its instance can call the method with instance.method().","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"class MyClass2:\r\n    def __init__(self, x):\r\n        self.x = x\r\n\r\n    def double(self):\r\n        return self.x * 2\r\n\r\nMyClass2(1).double() # => 2","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"However, in Julia, field accessing is using dot operators, while method accessing is not related to instances or even types. Methods are defined juxtaposing the structs.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"struct MyClass2\r\n    a :: Int\r\nend\r\n\r\ndouble(self) = self.a * 2\r\n\r\ndouble(MyClass2(1)) # => 2","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"The translation of dot methods is maybe the most direct translation in this article. This is because all OOP languages do the same thing as Julia under the hood.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"If we DO want to support dot methods in Julia, just set up the same mechanism used by Python or any other OOP language that support bound methods (examples: C#, Python; counter examples: Java, JavaScript).","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"struct BoundMethod{Func, Self}\r\n    func :: Func\r\n    self :: Self\r\nend\r\n\r\nfunction (boundmethod::BoundMethod{Func, Self})(args...; kwargs...) where {Func, Self}\r\n    boundmethod.func(boundmethod.self, args...; kwargs...)\r\nend\r\n\r\nBase.getproperty(self::MyClass2, name::Symbol) =\r\n    if name === :double\r\n        BoundMethod(double, self)\r\n    else\r\n        Base.getfield(self, name)\r\n    end\r\n\r\nMyClass2(1).double() # 2","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Supporting dot methods in Julia is NOT RECOMMANDED due to the poor IDE support and other conventions like \"dot operators access fields\".","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Besides, strongly coupling methods with classes is found not a general solution. A real-world counter example is operator overloading, where Julia's multiple dispatch is the-state-of-the-art solution to the problem. The infrastructure part of deep-learning frameworks requires facilities similar to multiple dispatch, where an evidence can be found from this discussion.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"You probably don't know an interesting fact: dot methods are not really a component of OOP, it's just a historical idiom of many OOP languages.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"From the perspective of programming languages, dot methods are so-called runtime single dispatch, and I've recently found that the popularity of runtime single dispatch has led to a general inability of identifying problems or requirements that are essentially multiple-dispatched. Such fact can be usually observed from the user API functions made by programmers from classic OOP languages.","category":"page"},{"location":"how-to-translate-oop-into-julia/#Julia-representation-of-inheritance","page":"Translating OOP into Idiomatic Julia","title":"Julia representation of inheritance","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Many smart programmers from the OOP world have already found the technique described above, but it seems that many of them give up in handling inheritance.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"However, a general solution to inheritance in Julia is still easy until we need syntactic sugar support.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"In Python, a class can inherit from other classes, and the child class can access the parents' fields and methods, or override some of the methods. We give the following example:","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"class A:\r\n    def __init__(self):\r\n        self.x = 1\r\n\r\nclass B:\r\n    def __init__(self, *args):\r\n        self.args = args\r\n\r\n    def print_args(self):\r\n        print(self.args)\r\n\r\nclass AB(A, B):\r\n    def __init__(self, *args):\r\n        A.__init__(self)\r\n        B.__init__(self, *args)\r\n\r\nab = AB(1, 2, 3)\r\nab.x # 1\r\nab.print_args() # (1, 2, 3)","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"To implement inheritance, we need basic understanding of what it is.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Inheritance in different OOP languages have different underlying implementations. Many statically-typed languages such as C++/Java/C# implement inheritance with composition, where a class instance implicitly holds base class instances (sizeof can be 0) as fields. However, dynamic languages such as Python provide inheritance similar to \"mixin\", where base classes are (usually) only related to reusing methods, and the instance is created only by the derived class's __new__ so that instances (usually) do not hold the base class instances. ","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"The major difference between these two implementations in the userland, other than performance, is the capability to have more than one same-name fields in different base classes or the derived class. Composition-based inheritance allows more than one same-name fields from different classes, but mixin-like inheritance implies the same name always references the the same member.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Efficient encoding of inheritance in Julia needs composition. This is because the mixin-like inheritance shares the same data (and its memory layout) for all base classes, then the instance have to be something like a dictionary, which is not preferred.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"The core idea of composition-based inheritance is very simple. Suppose our class inherits a base class BaseCls, which has a field base_field. As the base class instance is stored in a field of the derived class instance, accessing base_field is no more than firstly access the base class instance and use it to access the base_field normally.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Hence, the aforementioned Python code can be translated into:","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"mutable struct A <: OO\r\n    x :: Int\r\nend\r\n\r\nfunction init(self::A) \r\n    self.x = 1\r\nend\r\n\r\nmutable struct B <: OO\r\n    args\r\nend\r\n\r\nfunction init(self::B, args...)\r\n    self.args = args\r\nend\r\n\r\nprint_args(b) = println(b.args)\r\n\r\nmutable struct AB <: OO\r\n    _base_a :: A\r\n    _base_b :: B\r\nend\r\n\r\nfunction init(self::AB, args...)\r\n    self._base_a = A()   # A.__init__(self)\r\n    self._base_b = B(args...) # B.__init__(self, args...)\r\nend\r\n\r\nBase.getproperty(self::AB, name::Symbol) =\r\n    if name === :x\r\n        self._base_a.x\r\n    elseif name === :args\r\n        self._base_b.args\r\n    else\r\n        Base.getfield(self, name)\r\n    end\r\n\r\nab = AB(1, 2, 3)\r\nab.x # 1\r\nprint_args(ab) # (1, 2, 3)","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Note that methods applicable to base classes (e.g., print_args) also work for derived classes.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"However, the issues is that users have to manually create Base.getproperty, which is definitely not acceptable. Fortunately, the above code does suggest a general and efficient solution: when defining a class, we statically resolve which field name is referencing which field from which class, and finally generate a Base.getproperty (and Base.setproperty!).","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Julia allows this with runtime code generation (staging), providing us a zero-cost implementation.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Think that we use a special struct Inherit{T} to distinguish normal fields from the fields that store base class instances.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"struct Inherit{Cls}\r\n    base_inst :: Cls\r\nend\r\n\r\nmutable struct BaseCls <: OO\r\n    base_field :: Int\r\nend\r\n\r\nmutable struct DerivedCls <: OO\r\n    _base :: Inherit{BaseCls}\r\nend","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"In the following subsection, given x::DerivedCls, we make x.base_field retrieves x._base.base_inst.base_field.","category":"page"},{"location":"how-to-translate-oop-into-julia/#[Library-code](@ref-lib_inheritance)","page":"Translating OOP into Idiomatic Julia","title":"Library code","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"There is no need to fully understand the details, and the code is provided for copy-paste.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"struct Inherit{Cls}\r\n    base_inst :: Cls\r\nend\r\n\r\nBase.@pure function _pathed_fieldnames(@nospecialize(t))\r\n    t <: OO || error(\"Not an OO type\")\r\n    fts = fieldtypes(t)\r\n    fns = fieldnames(t)\r\n    pathed_names = Tuple{Tuple, Symbol}[]\r\n    for i in eachindex(fns, fts)\r\n        ft = fts[i]\r\n        if ft <: Inherit && ft isa DataType # concrete\r\n            base_t = ft.parameters[1]\r\n            for (path, n) in _pathed_fieldnames(base_t)\r\n                if !startswith(string(n), \"_\")\r\n                    push!(\r\n                        pathed_names,\r\n                        ((i, 1, path...), n))\r\n                end\r\n            end\r\n        else\r\n            # make '_xxx' private\r\n            push!(pathed_names, ((i, ), fns[i]))\r\n        end\r\n    end\r\n    Tuple(pathed_names)\r\nend\r\n\r\nBase.@pure function _fieldnames(@nospecialize(t))\r\n    Tuple(unique!([x[2] for x in _pathed_fieldnames(t)]))\r\nend\r\n\r\n@inline @generated function unroll_select(f, orelse, ::Val{tuple}, x, args...) where tuple\r\n    expr = Expr(:block)\r\n    foldr(tuple, init=:(return orelse(x))) do l, r\r\n        Expr(:if,\r\n            :(x === $(QuoteNode(l))),\r\n            :(return f($(Val(l)), args...)), r)\r\n    end\r\nend\r\n\r\n\r\n@inline @generated function _getproperty(self::T, ::Val{fieldname}) where {T <: OO, fieldname}\r\n    pathed_names = _pathed_fieldnames(T)\r\n    for (path, name) in pathed_names\r\n        if name === fieldname\r\n            return foldl(path, init=:self) do l, r\r\n                :($getfield($l, $r))\r\n            end\r\n        end\r\n    end\r\n    return :($error(\"type \" * string(T) * \" has no field \" * string(fieldname)))\r\nend\r\n\r\nfunction _do_with_field_found(typed_name::Val, self)\r\n    _getproperty(self, typed_name)\r\nend\r\n\r\n@inline function Base.getproperty(self::T, name::Symbol) where T <: OO\r\n    function _do_with_field_unfound(name::Symbol)\r\n        error(\"type $(string(T)) has no field $(string(unknown_name))\")\r\n    end\r\n    unroll_select(\r\n        _do_with_field_found,\r\n        _do_with_field_unfound,\r\n        Val(_fieldnames(T)),\r\n        name,\r\n        self,\r\n    )     \r\nend","category":"page"},{"location":"how-to-translate-oop-into-julia/#User-code-2","page":"Translating OOP into Idiomatic Julia","title":"User code","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Using the library code above, we can avoid manual implementation of Base.getproperty.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"mutable struct A <: OO\r\n    x :: Int\r\nend\r\n\r\nfunction init(self::A) \r\n    self.x = 1\r\nend\r\n\r\nmutable struct B <: OO\r\n    args\r\nend\r\n\r\nfunction init(self::B, args...)\r\n    self.args = args\r\nend\r\n\r\nprint_args(b) = println(b.args)\r\n\r\nmutable struct AB <: OO\r\n    _base_a :: Inherit{A}\r\n    _base_b :: Inherit{B}\r\nend\r\n\r\nfunction init(self::AB, args...)\r\n    self._base_a = Inherit(A())   # A.__init__(self)\r\n    self._base_b = Inherit(B(args...)) # B.__init__(self, args...)\r\nend\r\n\r\n\r\nab = AB(1, 2, 3)\r\nab.x # 1\r\nprint_args(ab) # (1, 2, 3)","category":"page"},{"location":"how-to-translate-oop-into-julia/#Julia-representation-of-interfaces","page":"Translating OOP into Idiomatic Julia","title":"Julia representation of interfaces","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"OOP uses interfaces to specify valid behaviours of an open family of classes. It helps the following programming requirements:","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"hiding implementation details about concrete classes\nreusing the functions for multiple classes\nspecifying constraints of input and output","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Recently, many OOP languages get started supporting default method implementations for interfaces, so interfaces are now not that different from multi-inheritable, zero-field abstract classes.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Interfaces in Python are not very standard, but they do work under the help of Python's mature IDEs.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Here is an example of using interfaces in Python:","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"class MyInterface:\r\n    def abs_func(self, arg):\r\n        raise NotImplementedError\r\n\r\n    def mixin_func(self, arg):\r\n        return \"mixin \" + self.abs_func(arg)\r\n\r\nclass Cls1(MyInterface):\r\n    def abs_func(self, arg):\r\n        return \"cls1\"\r\n\r\nclass Cls2(MyInterface):\r\n    def abs_func(self, arg):\r\n        return \"cls2\"\r\n\r\n# Use interfaces!\r\ndef func_reusing_for_multi_classes(self: MyInterface, arg):\r\n    return self.mixin_func(arg)\r\n\r\nfunc_reusing_for_multi_classes(Cls2(), \"xxx\") # \"mixin cls2\"","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Such code can be translated into Julia using abstract type:","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"abstract type MyInterface end\r\nabs_func(self::MyInterface, arg) =\r\n    error(\"'abs_func' is not defined for $(typeof(self)).\")\r\n\r\nmixin_func(self::MyInterface, arg) =\r\n    \"mixin \" * abs_func(self, arg)\r\n\r\nstruct Cls1 <: MyInterface end\r\nstruct Cls2 <: MyInterface end\r\n\r\nabs_func(self::Cls1, arg) = \"cls1\"\r\nabs_func(self::Cls2, arg) = \"cls2\"\r\n\r\n# Use interfaces!\r\nfunc_reusing_for_multi_classes(self::MyInterface, arg) =\r\n    mixin_func(self, arg)\r\n\r\nfunc_reusing_for_multi_classes(Cls2(), \"xxx\") # \"mixin cls2\"","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"As can be seen above, the code in Julia is slightly more concise than that in Python.","category":"page"},{"location":"how-to-translate-oop-into-julia/#Conclusions","page":"Translating OOP into Idiomatic Julia","title":"Conclusions","text":"","category":"section"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"OOP features, such as constructors, methods, inheritance, and interfaces, have corresponding translation in Julia.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"For most of tasks involving OOP, the translation is straightforward and even more concise than the original code.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"However, we'd still admit such translation has limitations, while the limitation is never about missing language features.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"A notable limitation is about the performance of the runtime polymorphisms. OOP's polymorphism is vtable-based runtime polymorphism, which makes OOP code run pretty fast when handling a container of abstract typed elements. Julia performs worse in this case when you translate OOP code into Julia, to which there is no general solution.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"Another important limitation is about IDE support or code introspection. I'm always thinking that people are not really complaining about Julia's lack of OOP support, but the lack of dot operators, I mean, some language facility to organize and search definitions.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"For instance, if I know a class is iterable, I'd like to know the available methods (such as iterate) or fields by simply typing something.<TAB>. So far we have to browse the documentation, otherwise we cannot even find out the methods intentionally defined for some abstract type.","category":"page"},{"location":"how-to-translate-oop-into-julia/","page":"Translating OOP into Idiomatic Julia","title":"Translating OOP into Idiomatic Julia","text":"(Possibly off-topic) I don't really want to be a boring guy who talks about how much better a FP language could be, but if possible we could learn about API organization from Erlang or Haskell. If operations for iterables are registered in a module Iterables, and Iterables.<TAB> shows iterate in the completion list for me, I'd be more satisfied.","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"CurrentModule = TyOOP","category":"page"},{"location":"index-cn/#TyOOP","page":"TyOOP","title":"TyOOP","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"TyOOP为Julia提供一套相对完整的面向对象机制，设计上主要基于CPython的面向对象，对Julia做了适配。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"其功能一览如下：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"功能名 支持 注释\n点操作符 是 \n继承 是 基类、子类不能直接转换\n构造器和实例方法重载 是 基于多重分派\n多继承 是 MRO基于变种C3算法\nPython风格 properties 是 \n默认字段 是 \n泛型 是 \n接口 是 使用空结构体类型做基类\n权限封装(modifiers) 否 同Python\n类静态方法 否 不实现，避免type piracy\n元类(metaclass) 否 不实现，推荐宏处理","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"快速学习请参考TyOOP Cheat Sheet.","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"必须强调的是，我们非常认可Julia社区关于“不要在Julia中做OOP”的观点。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"我们创建这个指南 将OOP翻译到地道的Julia，以指导用户如何将OOP代码翻译为更简短、更高效的Julia代码。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"我们更是花费精力将TyOOP设计成这个样子：OOP的使用能被局限在坚定的OOP使用者的代码里，通过接口编程，这些OOP代码和正常的Julia对接，以避免不合适的代码在外部泛滥。","category":"page"},{"location":"index-cn/#OO类型定义","page":"TyOOP","title":"OO类型定义","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"TyOOP支持定义class和struct，class使用@oodef mutable struct开头，struct使用@oodef struct开头。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"using TyOOP\r\n@oodef struct MyStruct\r\n    a :: Int\r\n    function new(a::Int)\r\n        @mk begin\r\n            a = a\r\n        end\r\n    end\r\n    function f(self)\r\n        self.a\r\n    end\r\nend\r\n\r\n@oodef mutable struct MyClass\r\n    a :: Int\r\n    function new(a::Int)\r\n        @mk begin\r\n            a = a\r\n        end\r\n    end\r\n    function f(self)\r\n        self.a\r\n    end\r\nend","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"上述代码中，function new(...)用于定义构造器。 构造器的返回值应当使用@mk begin ... end构造一个当前类型的实例，其中，begin语句块中使用字段名=值初始化字段。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"缺省构造器的行为：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"当类型为class，所有字段未初始化。\n当类型为struct，且存在字段，使用Julia生成的构造器(dataclass)","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"构造器可以被重载。对于空间占用为0的结构体(单例类型)，构造器可以省略。","category":"page"},{"location":"index-cn/#实例方法","page":"TyOOP","title":"实例方法","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"实例方法须以function 方法名(类实例, ...)开头。类实例变量推荐命名为self或this。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"前面代码里MyClass和MyStruct都实现了实例方法f, 它们的实例，比方说instance::MyClass，以instance.f()的语法调用该方法。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef mutable struct MyClass\r\n    a :: Int\r\n    # ... 省略部分定义\r\n    function f(self)\r\n        self.a\r\n    end\r\nend","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"实例方法支持任意形式的Julia参数，如变长参数，关键字参数，变长关键字参数，默认参数，默认关键字参数。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"此外，实例方法支持泛型，且能被重载。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"P.S: 如果要标注self参数的类型，应该使用self :: @like(MyClass)而不是self :: MyClass。这是因为实例方法可能被子类调用，而Julia不能支持隐式转换。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"P.P.S: 什么是@like？对于一个OO类型Parent, 任何继承自Parent的子类Child满足Child <: @like(Parent)，其中<:是Julia原生的subtyping运算。","category":"page"},{"location":"index-cn/#默认字段","page":"TyOOP","title":"默认字段","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"TyOOP支持默认字段。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"在为类型定义一个字段时，如果为这个字段指定默认值，那么@mk宏允许缺省该字段的初始化。注意，如果不定义new函数并使用@mk宏，默认字段将无效。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"function get_default_field2()\r\n    println(\"default field2!\")\r\n    return 30\r\nend\r\n\r\n@oodef struct MyType\r\n    field1 :: DataType = MyType\r\n    field2 :: Int = get_default_field2()\r\n\r\n    function new()\r\n        return @mk\r\n    end\r\n\r\n    function new(field2::Integer)\r\n        return @mk field2 = field2\r\n    end\r\nend\r\n\r\njulia> MyType()\r\ndefault field2!\r\nMyType(MyType, 30)\r\n\r\njulia> MyType(50)\r\nMyType(MyType, 50)","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"关于默认字段的注意点：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"默认字段没有性能开销。\n在@mk块显式指定字段初始化时，默认字段的求值表达式不会被执行。\n与Base.@kwdef不同，默认字段的求值表达式无法访问其他字段。","category":"page"},{"location":"index-cn/#Python风格的构造器","page":"TyOOP","title":"Python风格的构造器","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"以往的OO语言，如Python/C++/Java/C#，没有原生支持的不可变类型，因此构造器的工作一般设计为：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"创建一个新对象self(或this)\n利用构造器参数对self进行初始化","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"Julia也支持这样的构造方式，但只对mutable struct有效，且不推荐。写法如下:","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef mutable struct MySubclass <: {MySuperclass1, MySuperclass2}\r\n    field1\r\n    function new()\r\n        self = @mk\r\n        # 初始化字段\r\n        self.field1 = 1\r\n        ## 记住需要返回\r\n        return self\r\n    end","category":"page"},{"location":"index-cn/#inheritance_cn","page":"TyOOP","title":"继承，多继承","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"下面是一个简单的继承例子。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"首先我们用@oodef定义两个结构体类型:","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct A\r\n    a :: Int\r\nend\r\n\r\n@oodef struct B\r\n    b :: Int\r\nend","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"随后，我们用一个类型C继承上面两个类型。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct C <: {A, B}\r\n    c :: String\r\n    function new(a::Int, b::Int, c::String = \"somestring\")\r\n        @mk begin\r\n            A(a), B(b)\r\n            c = c\r\n        end\r\n    end\r\nend\r\n\r\nc = C(1, 2)\r\n@assert c.a === 1\r\n@assert c.b === 2","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"可以看到，我们使用在@mk块中使用Base1(arg1, arg2), Base2(arg1, arg2)来设置基类，这和Python中的基类.__init__(self, args...)一致。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"一个子类可以继承多个基类，当多个基类出现重名属性时，使用C3线性化算法来选取成员。我们使用的C3算法是一个变种，能允许更灵活的mixin抽象。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"下面给出一个mixin的例子。mixin是继承的一种常见应用：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"我们定义一个基类，多边形IPolygon，它的子类可能有正方形、长方形、三角形乃至一般的多边形，但这些子类都共享一个标准的周长求解算法：将所有边的长度相加。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"则多边形的基类，可以用如下代码定义：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"using TyOOP\r\n\r\nconst Point = Tuple{Float64, Float64}\r\nfunction distance(source::Point, destination::Point)\r\n    sqrt(\r\n        (destination[1] - source[1]) ^ 2 +\r\n        (destination[2] - source[2]) ^ 2)\r\nend\r\n\r\n@oodef struct IPolygon\r\n    # 抽象方法\r\n    function get_edges end\r\n\r\n    # mixin方法\r\n    function get_perimeter(self)\r\n        s = 0.0\r\n        vs = self.get_edges() :: AbstractVector{Point}\r\n        if length(vs) <= 1\r\n            0.0\r\n        end\r\n        last = vs[1] :: Point\r\n        for i = 2:length(vs)\r\n            s += distance(vs[i], last)\r\n            last = vs[i]\r\n        end\r\n        s += distance(vs[end], vs[1])\r\n        return s\r\n    end\r\nend","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"利用上述基类IPolygon，我们可以实现子类，并复用其中的get_perimeter方法。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"例如，矩形Rectangle：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct Rectangle <: IPolygon\r\n    width :: Float64\r\n    height :: Float64\r\n    center :: Point\r\n\r\n    function new(width::Float64, height::Float64, center::Point)\r\n        @mk begin\r\n            width = width\r\n            height = height\r\n            center = center\r\n        end\r\n    end\r\n\r\n    function get_edges(self)\r\n        x0 = self.center[1]\r\n        y0 = self.center[2]\r\n        h = self.height / 2\r\n        w = self.width / 2\r\n        Point[\r\n            (x0 - w, y0 - h),\r\n            (x0 - w, y0 + h),\r\n            (x0 + w, y0 + h),\r\n            (x0 + w, y0 - h)\r\n        ]\r\n    end\r\n\r\n    # 对特殊的子类，可以重写 get_perimeter 获得更快的求周长方法\r\n    # function get_perimeter() ... end\r\nend\r\n\r\nrect = Rectangle(3.0, 2.0, (5.0, 2.0))\r\n@assert rect.get_perimeter() == 10.0","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"P.S: 由TyOOP定义的OO类型，只能继承其他OO类型。","category":"page"},{"location":"index-cn/#Python风格的properties","page":"TyOOP","title":"Python风格的properties","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"在Java中，getter函数(get_xxx)和setter(set_xxx)函数用来隐藏实现细节，暴露稳定的API。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"对于其中冗余，很多语言如Python提供了一种语法糖，允许抽象self.xxx和self.xxx = value，这就是property。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"TyOOP支持property，用以下的方式：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct DemoProp\r\n    @property(value) do\r\n        get = self -> 100\r\n        set = (self, value) -> println(\"setting $value\")\r\n    end\r\nend\r\n\r\nprintln(DemoProp().value) # => 100\r\nDemoProp().value = 200 # => setting 200","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"下面是一个更加实际的例子：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef mutable struct Square\r\n    side :: Float64\r\n    function new(side::Number)\r\n        @mk begin\r\n            side = convert(Float64, side)\r\n        end\r\n    end\r\n\r\n    @property(area) do\r\n        get = self -> self.side ^ 2\r\n        set = function (self, value)\r\n            self.side = sqrt(value)\r\n        end\r\n    end\r\nend\r\n\r\nsquare = Square(5) # => Square(5.0)\r\nsquare.area # => 25.0\r\nsquare.area = 16 # => 16\r\nsquare.side # => 4.0","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"可以看到，在设置面积的同时，正方形的边长得到相应改变。","category":"page"},{"location":"index-cn/#advanced_absmeths_and_absprops_cn","page":"TyOOP","title":"高级特性：抽象方法和抽象property","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct AbstractSizedContainer{ElementType}\r\n\r\n    # 定义一个抽象方法\r\n    function contains end\r\n\r\n\r\n    # 定义一个抽象getter\r\n    @property(length) do\r\n        get\r\n    end\r\nend\r\n\r\n# 打印未实现的方法（包括property）\r\nTyOOP.check_abstract(AbstractSizedContainer)\r\n# =>\r\n# Dict{PropertyName, TyOOP.CompileTime.PropertyDefinition} with 2 entries:\r\n#  contains (getter) => PropertyDefinition(:contains, missing, AbstractSizedContainer, MethodKind)\r\n#  length (getter)   => PropertyDefinition(:length, missing, AbstractSizedContainer, GetterPropertyKind)\r\n\r\n@oodef struct MyNumSet{E <: Number} <: AbstractSizedContainer{E}\r\n    inner :: Set{E}\r\n    function new(args::E...)\r\n        @mk begin\r\n            inner = Set{E}(args)\r\n        end\r\n    end\r\n\r\n    # if no annotations for 'self',\r\n    # annotations and type parameters can be added like:\r\n    # 'function contains(self :: @like(MySet{E}), e::E) where E'\r\n    function contains(self, e::E)\r\n        return e in self.inner\r\n    end\r\n\r\n    @property(length) do\r\n        get = self -> length(self.inner)\r\n    end\r\nend\r\n\r\nmy_set = MySet(1, 2, 3)\r\nmy_set.length # => 3\r\nmy_set.contains(2) # => true","category":"page"},{"location":"index-cn/#高级特性：泛型","page":"TyOOP","title":"高级特性：泛型","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"泛型无处不在，业务中常见于容器。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"在抽象方法一节，我们介绍了AbstractSizedContainer，可以看到它有一个泛型参数ElementType。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct AbstractSizedContainer{ElementType}\r\n    # (self, ::ElementType) -> Bool\r\n    function contains end\r\n    function get_length end\r\nend","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"虽然在定义时没有用到这个类型，但在子类定义时，该类型参数能用来约束容器的元素类型。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"TyOOP支持各种形式的Julia泛型，下面是一些例子。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"# 数字容器\r\n@oodef struct AbstactNumberContainer{ElementType <: Number}\r\n    ...\r\nend\r\n\r\n# 用来表示任意类型的可空值\r\n@oodef struct Optional{T}\r\n    value :: Union{Nothing, Some{T}}\r\nend","category":"page"},{"location":"index-cn/#高级特性：显式泛型类型参数","page":"TyOOP","title":"高级特性：显式泛型类型参数","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"下面的代码给出一个特别的例子，构造器new无法从参数类型推断出泛型类型参数A。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct MyGenType{A}\r\n    a :: Int\r\n    function new(a::Int)\r\n        new{A}(a)\r\n    end\r\nend","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"在这种情况下，可以显式指定泛型类型参数，构造类型实例：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"my_gen_type = MyGenType{String}(1)\r\nmy_gen_type = MyGenType{Number}(1)\r\nmy_gen_type = MyGenType{Vector{Int}}(1)","category":"page"},{"location":"index-cn/#高级特性：接口","page":"TyOOP","title":"高级特性：接口","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"TyOOP支持接口编程：使用@oodef struct定义一个没有字段的结构体类型，为它添加一些抽象方法，这样就实现了接口。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"除开业务上方便对接逻辑外，接口还能为代码提供合适的约束。","category":"page"},{"location":"index-cn/#@like(ootype)","page":"TyOOP","title":"@like(ootype)","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@like 将具体的OO类型转为某种特殊的Julia抽象类型。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"julia> @like(HasLength)\r\nObject{>:var\"HasLength::trait\"}","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"在Julia的类型系统中，具体类型不能被继承。其直接影响是，Julia的多重分派无法接受子类实例，如果参数标注为父类。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct SuperC end\r\n@oodef struct SubC <: SuperC end\r\nfunction f(::SuperC) end\r\nf(SuperC()) # ok\r\nf(SubC())   # err","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@like(ootype) 很好地解决了这一问题。类型标注为@like(HasLength)的函数参量可以接受HasLength的任意子类型。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct SuperC end\r\n@oodef struct SubC <: SuperC end\r\nfunction f(::@like(SuperC)) end\r\nf(SuperC()) # ok\r\nf(SubC())   # ok!","category":"page"},{"location":"index-cn/#例子，和零开销抽象","page":"TyOOP","title":"例子，和零开销抽象","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"基于下面定义的接口HasLength，我们定义一个普通的Julia函数a_regular_julia_function：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct HasLength\r\n    function get_length end\r\nend\r\n\r\nfunction a_regular_julia_function(o :: @like(HasLength))\r\n    function some_random_logic(i::Integer)\r\n        (i * 3 + 5) ^ 2\r\n    end\r\n    some_random_logic(o.get_length())\r\nend","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"现在，我们为HasLength实现一个子类MyList，作为Vector类型的包装：","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@oodef struct MyList{T} <: HasLength\r\n    inner :: Vector{T}\r\n\r\n    function new(elts::T...)\r\n        @mk begin\r\n            inner = collect(T, elts)\r\n        end\r\n    end\r\n\r\n    function get_length(self)\r\n        length(self.inner)\r\n    end\r\nend\r\n\r\na_regular_julia_function(MyList(1, 2, 3)) # 196\r\na_regular_julia_function([1]) # error","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"可以看到，只有实现了HasLength的OO类型可以应用a_regular_julia_function。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"此外，我们指出，TyOOP的接口编程本身不导致动态分派。如果代码是静态分派的，抽象是零开销的。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@code_typed a_regular_julia_function(MyList(1, 2, 3))\r\nCodeInfo(\r\n1 ─ %1 = (getfield)(o, :inner)::Vector{Int64}\r\n│   %2 = Base.arraylen(%1)::Int64\r\n│   %3 = Base.mul_int(%2, 3)::Int64\r\n│   %4 = Base.add_int(%3, 5)::Int64\r\n│   %5 = Base.mul_int(%4, %4)::Int64\r\n└──      return %5\r\n) => Int64\r\n\r\njulia> @code_llvm a_regular_julia_function(MyList(1, 2, 3))\r\n;  @ REPL[6]:1 within `a_regular_julia_function`\r\n; Function Attrs: uwtable\r\ndefine i64 @julia_a_regular_julia_function_1290({ {}* }* nocapture nonnull readonly align 8 dereferenceable(8) %0) #0 {\r\ntop:\r\n    %1 = bitcast { {}* }* %0 to { i8*, i64, i16, i16, i32 }**\r\n    %2 = load atomic { i8*, i64, i16, i16, i32 }*, { i8*, i64, i16, i16, i32 }** %1 unordered, align 8\r\n    %3 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %2, i64 0, i32 1\r\n    %4 = load i64, i64* %3, align 8\r\n    %5 = mul i64 %4, 3\r\n    %6 = add i64 %5, 5\r\n    %7 = mul i64 %6, %6\r\n  ret i64 %7\r\n}","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"P.S: 为接口增加默认方法可以实现著名的Mixin抽象。见继承，多继承中的IPolygon类型。","category":"page"},{"location":"index-cn/#用@typed_access解决性能问题","page":"TyOOP","title":"用@typed_access解决性能问题","text":"","category":"section"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"因为编译器优化原因，使用Python风格的property会导致类型推导不够精准，降低性能。 对于可能的性能损失，我们提供@typed_access宏，在兼容julia原生语义的条件下，自动优化所有的a.b操作。","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@typed_access begin\r\n    instance1.method(instance2.property)\r\nend\r\n\r\n# 等价于\r\n\r\nTyOOP.typed_access(instance1, Val(:method))(\r\n    TyOOP.typed_access(instance, Val(:property))\r\n)","category":"page"},{"location":"index-cn/","page":"TyOOP","title":"TyOOP","text":"@typed_access让动态分派更慢，让静态分派更快。对于a.b，如果a的类型被Julia成功推断，则@typed_access a.b不会比a.b慢。","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TyOOP","category":"page"},{"location":"#TyOOP","page":"Home","title":"TyOOP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"中文文档","category":"page"},{"location":"","page":"Home","title":"Home","text":"TyOOP provides relatively complete object-oriented programming support for Julia. This is mainly based on CPython's object-oriented programming, and adapted for Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The feature list is given below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"feature support notes\ninheritance yes upcasts/downcasts are not supported\noverloaded constructors and methods yes based on multiple dispatch\nmultiple inheritance yes MRO based on C3\nPython-style properties yes \ndefault field values yes \ngenerics yes \ninterfaces yes singleton struct types as base classes\nmodifiers no just like Python\nstatic class methods no won't fix to avoid type piracy\nmetaclasses no won't fix in favour of macros","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quick start through TyOOP Cheat Sheet.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that we very much support the community idea \"do not do OOP in Julia\".","category":"page"},{"location":"","page":"Home","title":"Home","text":"We make this guide Translating OOP into Idiomatic Julia to instruct users on how to translate OOP code into Julia, promising more concise, more extensible and more efficient code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We even took the effort to design TyOOP as what it is now: the usage of OOP can be confined to the code of committed OOP users, and through interface programming, code of OOP exports APIs in normal Julia to avoid the proliferation of inappropriate code outside.","category":"page"},{"location":"#OO-type-definition","page":"Home","title":"OO type definition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TyOOP supports defining classes and structs. A class definition starts with @oodef mutable struct, while a struct definition starts with @oodef struct.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TyOOP\r\n@oodef struct MyStruct\r\n    a :: Int\r\n    function new(a::Int)\r\n        @mk begin\r\n            a = a\r\n        end\r\n    end\r\n    function f(self)\r\n        self.a\r\n    end\r\nend\r\n\r\n@oodef mutable struct MyClass\r\n    a :: Int\r\n    function new(a::Int)\r\n        @mk begin\r\n            a = a\r\n        end\r\n    end\r\n    function f(self)\r\n        self.a\r\n    end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"As shown above, function new(...) is responsible for defining class/struct constructors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We recommand using a @mk begin ... end block as the return value. In the block, you can specify zero or more field_name = field_value to initialize fields.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The behaviour when missing constructors:","category":"page"},{"location":"","page":"Home","title":"Home","text":"if the type is a class (mutable struct), all fields are not initialized, as well as all base instances.\nif the type is a struct, using Julia's default constructor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Constructors can be overloaded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the struct types whose memory consumption is 0, constructors can be omitted.","category":"page"},{"location":"#Instance-methods","page":"Home","title":"Instance methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"instance methods should start with function method_name(class_instance, ...). The instance variable is recommended to be named self or this.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The above code in both MyClass and MyStruct implement a method f. The method can be invoked using the syntax instance.f().","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef mutable struct MyClass\r\n    a :: Int\r\n    \r\n    # ... this part is omitted\r\n\r\n    function f(self)\r\n        self.a\r\n    end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instance methods support aribitrary Julia parameters, such as variadic parameters, keyword arguments, variadic keyword arguments, default positional arguments and default keyword arguments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Besides, the instance methods support generic parameters, and can be overloaded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(P.S) If you want to annotate the self parameter, it is recommended to use self :: @like(MyClass) instead of self :: MyClass. This is because the method might be invoked by the subclasses, while Julia does not support implicit conversions between types.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(P.P.S) What is @like? Given an OO type Parent, any subtype Child (also an OO type) inheriting Parent satisfies Child <: @like(Parent) in Julia, where <: is Julia's native subtyping operator. Child <: Parent can only be false in Julia.","category":"page"},{"location":"#Default-field-values","page":"Home","title":"Default field values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Using this feature, when defining a field for classes/structs, if a default value is provided, then the initialization for this field can be missing in the @mk block.","category":"page"},{"location":"","page":"Home","title":"Home","text":"function get_default_field2()\r\n    println(\"default field2!\")\r\n    return 30\r\nend\r\n\r\n@oodef struct MyType\r\n    field1 :: DataType = MyType\r\n    field2 :: Int = get_default_field2()\r\n\r\n    function new()\r\n        return @mk\r\n    end\r\n\r\n    function new(field2::Integer)\r\n        return @mk field2 = field2\r\n    end\r\nend\r\n\r\njulia> MyType()\r\ndefault field2!\r\nMyType(MyType, 30)\r\n\r\njulia> MyType(50)\r\nMyType(MyType, 50)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some points of the default field values:","category":"page"},{"location":"","page":"Home","title":"Home","text":"there is no performance overhead in using default field values.\nwhen a field has been explicitly initialized in the @mk block, the expression of the default field value won't be evaluated.\nunlike Base.@kwdef, default field values cannot reference each other.","category":"page"},{"location":"#Python-style-constructors","page":"Home","title":"Python-style constructors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The traditional OO languages such Python/C++/Java/C# do not have native immutable types, so that the jobs of a constructor can be designed as follow:","category":"page"},{"location":"","page":"Home","title":"Home","text":"creating a new instance self of the type.\ninvoking a constructor function to initialize the self instance. Side effects are introduced.","category":"page"},{"location":"","page":"Home","title":"Home","text":"TyOOP can support such style for classes (mutable structs), but it is not our best practice.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef mutable struct MySubclass <: {MySuperclass1, MySuperclass2}\r\n    field1\r\n    function new()\r\n        self = @mk\r\n        # init fields\r\n        self.field1 = 1\r\n        # remember to return self\r\n        return self\r\n    end","category":"page"},{"location":"#inheritance","page":"Home","title":"Inheritances and multiple inheritances","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is a simple example of class inheritance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We firstly define two structs using @oodef:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct A\r\n    a :: Int\r\nend\r\n\r\n@oodef struct B\r\n    b :: Int\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we define a type C to inherit A and B:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct C <: {A, B}\r\n    c :: String\r\n    function new(a::Int, b::Int, c::String = \"somestring\")\r\n        @mk begin\r\n            A(a), B(b)\r\n            c = c\r\n        end\r\n    end\r\nend\r\n\r\nc = C(1, 2)\r\n@assert c.a === 1\r\n@assert c.b === 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"As can be seen, in the @mk block, we use Base1(arg1, arg2), Base2(arg1, arg2) to call the base classe constructors, which corresponds to BaseType.__init__(self, arg1, arg2) in Python.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A struct/class can inherit multiple base classes/structs. When name collision happens, we use C3 linearization algorithm to decide which one is to select. We use a variant of C3 to allow more flexible mixin uses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following example introduces mixin which is a common use of (multiple) inheritances:","category":"page"},{"location":"","page":"Home","title":"Home","text":"We define a base class IPolygon which might have subclasses Square, Rectangle, Triangle or even general polygons. Despite the differences between these possible subclasses, a standard algorithm to compute perimeters is shared: sum up the lengths of all the edges.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TyOOP\r\n\r\nconst Point = Tuple{Float64, Float64}\r\nfunction distance(source::Point, destination::Point)\r\n    sqrt(\r\n        (destination[1] - source[1]) ^ 2 +\r\n        (destination[2] - source[2]) ^ 2)\r\nend\r\n\r\n@oodef struct IPolygon\r\n    # abstract method\r\n    function get_edges end\r\n\r\n    # mixin method\r\n    function get_perimeter(self)\r\n        s = 0.0\r\n        vs = self.get_edges() :: AbstractVector{Point}\r\n        if length(vs) <= 1\r\n            0.0\r\n        end\r\n        last = vs[1] :: Point\r\n        for i = 2:length(vs)\r\n            s += distance(vs[i], last)\r\n            last = vs[i]\r\n        end\r\n        s += distance(vs[end], vs[1])\r\n        return s\r\n    end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Leveraging the above IPolygon, we can define subclasses, reusing the get_perimeter method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance, Rectangle：","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct Rectangle <: IPolygon\r\n    width :: Float64\r\n    height :: Float64\r\n    center :: Point\r\n\r\n    function new(width::Float64, height::Float64, center::Point)\r\n        @mk begin\r\n            width = width\r\n            height = height\r\n            center = center\r\n        end\r\n    end\r\n\r\n    function get_edges(self)\r\n        x0 = self.center[1]\r\n        y0 = self.center[2]\r\n        h = self.height / 2\r\n        w = self.width / 2\r\n        Point[\r\n            (x0 - w, y0 - h),\r\n            (x0 - w, y0 + h),\r\n            (x0 + w, y0 + h),\r\n            (x0 + w, y0 - h)\r\n        ]\r\n    end\r\n\r\n    # for very special subclasses, we can overwrite\r\n    # 'get_perimeter' to have a faster version:\r\n    # function get_perimeter(self) ... end\r\nend\r\n\r\nrect = Rectangle(3.0, 2.0, (5.0, 2.0))\r\n@assert rect.get_perimeter() == 10.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"P.S: OO types shall only inherit from OO types defined using TyOOP.","category":"page"},{"location":"#Python-style-properties","page":"Home","title":"Python-style properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Java, the getter functions get_xxx and setter functions set_xxx are used to encapsulate the implementation details and export more stable APIs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The syntactic redundancies involved above can be adddressed by a syntatic sugar, which is named \"properties\" by many languages such as Python.","category":"page"},{"location":"","page":"Home","title":"Home","text":"TyOOP supports so-called \"properties\", in the following apprach:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct DemoProp\r\n    @property(value) do\r\n        get = self -> 100\r\n        set = (self, value) -> println(\"setting $value\")\r\n    end\r\nend\r\n\r\nprintln(DemoProp().value) # => 100\r\nDemoProp().value = 200 # => setting 200","category":"page"},{"location":"","page":"Home","title":"Home","text":"A more practical example is given below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef mutable struct Square\r\n    side :: Float64\r\n    function new(side::Number)\r\n        @mk begin\r\n            side = side # support auto cast\r\n        end\r\n    end\r\n\r\n    @property(area) do\r\n        get = self -> self.side ^ 2\r\n        set = function (self, value)\r\n            self.side = sqrt(value)\r\n        end\r\n    end\r\nend\r\n\r\nsquare = Square(5) # => Square(5.0)\r\nsquare.area # => 25.0\r\nsquare.area = 16 # => 16\r\nsquare.side # => 4.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"As can be seen, the side length of the square changes accordingly as the area gets changed.","category":"page"},{"location":"#advanced_absmeths_and_absprops","page":"Home","title":"Advanced feature: Abstract methods, and abstract properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@oodef struct AbstractSizedContainer{ElementType}\r\n\r\n    # abstract method\r\n    function contains end\r\n\r\n\r\n    # abstract property with only getter\r\n    @property(length) do\r\n        get\r\n    end\r\nend\r\n\r\n# print not implemented methods (including properties)\r\nTyOOP.check_abstract(AbstractSizedContainer)\r\n# =>\r\n# Dict{PropertyName, TyOOP.CompileTime.PropertyDefinition} with 2 entries:\r\n#  contains (getter) => PropertyDefinition(:contains, missing, AbstractSizedContainer, MethodKind)\r\n#  length (getter)   => PropertyDefinition(:length, missing, AbstractSizedContainer, GetterPropertyKind)\r\n\r\n@oodef struct MyNumSet{E <: Number} <: AbstractSizedContainer{E}\r\n    inner :: Set{E}\r\n    function new(args::E...)\r\n        @mk begin\r\n            inner = Set{E}(args)\r\n        end\r\n    end\r\n\r\n    # if no annotations for 'self',\r\n    # annotations and type parameters can be added like:\r\n    # 'function contains(self :: @like(MySet{E}), e::E) where E'\r\n    function contains(self, e::E)\r\n        return e in self.inner\r\n    end\r\n\r\n    @property(length) do\r\n        get = self -> length(self.inner)\r\n    end\r\nend\r\n\r\nmy_set = MySet(1, 2, 3)\r\nmy_set.length # => 3\r\nmy_set.contains(2) # => true","category":"page"},{"location":"#Advanced-feature:-Generics","page":"Home","title":"Advanced feature: Generics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generics are pervasive, and in practice very common in data structures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"At Advanced features：Abstract methods, and abstract properties, we have introduced AbstractSizedContainer. It has a generic type parameter ElementType.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct AbstractSizedContainer{ElementType}\r\n    # (self, ::ElementType) -> Bool\r\n    function contains end\r\n    @property(length) do\r\n        get\r\n    end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Although we do not use ElementType in the above example, it is useful if we need to specify a container's element type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# containers of only numbers\r\n@oodef struct AbstactNumberContainer{ElementType <: Number}\r\n    ...\r\nend\r\n\r\n@oodef struct Optional{T}\r\n    value :: Union{Nothing, Some{T}}\r\nend","category":"page"},{"location":"#Advanced-feature:-Explicit-generic-type-parameters","page":"Home","title":"Advanced feature: Explicit generic type parameters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following code shows a special case where the constructor new cannot infer the generic type parameter A from the arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct MyGenType{A}\r\n    a :: Int\r\n    function new(a::Int)\r\n        new{A}(a)\r\n    end\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this case, we can explicitly specify the generic type parameters to construct instances:","category":"page"},{"location":"","page":"Home","title":"Home","text":"my_gen_type = MyGenType{String}(1)\r\nmy_gen_type = MyGenType{Number}(1)\r\nmy_gen_type = MyGenType{Vector{Int}}(1)","category":"page"},{"location":"#Advanced-feature:-Interfaces","page":"Home","title":"Advanced feature: Interfaces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TyOOP supports interface programming. Use @oodef struct to define a struct which has no fields, and add some abstract/mixin methods to it, in this way we achieve interface programming.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Despite the ease of connecting with the real business logic, interfaces also helps to specify proper constraints in your code.","category":"page"},{"location":"#@like(ootype)","page":"Home","title":"@like(ootype)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"@like transforms a concrete OO type into a special abstract type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> @like(HasLength)\r\nObject{>:var\"HasLength::trait\"}","category":"page"},{"location":"","page":"Home","title":"Home","text":"In Julia's type system, no concrete type can be inherited. A direct implication is that Julia's multiple dispatch does not accept a subtype instance if the parameter is annotated a base type. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct SuperC end\r\n@oodef struct SubC <: SuperC end\r\nfunction f(::SuperC) end\r\nf(SuperC()) # ok\r\nf(SubC())   # err","category":"page"},{"location":"","page":"Home","title":"Home","text":"@like(ootype) addresses this. A function parameter @like(HasLength) accepts instances of any type that is a subtype of HasLength.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct SuperC end\r\n@oodef struct SubC <: SuperC end\r\nfunction f(::@like(SuperC)) end\r\nf(SuperC()) # ok\r\nf(SubC())   # ok!","category":"page"},{"location":"#Examples,-and-zero-cost-abstraction","page":"Home","title":"Examples, and zero-cost abstraction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following code based on the interface HasLength defines a regular Julia function a_regular_julia_function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct HasLength\r\n    function get_length end\r\nend\r\n\r\nfunction a_regular_julia_function(o :: @like(HasLength))\r\n    function some_random_logic(i::Integer)\r\n        (i * 3 + 5) ^ 2\r\n    end\r\n    some_random_logic(o.get_length())\r\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, we define a substruct MyList that inherits from HasLength, as the user wrapper of Julia's builtin Vector type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@oodef struct MyList{T} <: HasLength\r\n    inner :: Vector{T}\r\n\r\n    function new(elts::T...)\r\n        @mk begin\r\n            inner = collect(T, elts)\r\n        end\r\n    end\r\n\r\n    function get_length(self)\r\n        length(self.inner)\r\n    end\r\nend\r\n\r\na_regular_julia_function(MyList(1, 2, 3)) # 196\r\na_regular_julia_function([1]) # error","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can see that only the OO type that implements HasLength is accepted by a_regular_julia_function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, we point out that such interface abstraction itself does not introduce any dynamic dispatch. If your code contains only static dispatch, the abstraction is zero-cost.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@code_typed a_regular_julia_function(MyList(1, 2, 3))\r\nCodeInfo(\r\n1 ─ %1 = (getfield)(o, :inner)::Vector{Int64}\r\n│   %2 = Base.arraylen(%1)::Int64\r\n│   %3 = Base.mul_int(%2, 3)::Int64\r\n│   %4 = Base.add_int(%3, 5)::Int64\r\n│   %5 = Base.mul_int(%4, %4)::Int64\r\n└──      return %5\r\n) => Int64\r\n\r\njulia> @code_llvm a_regular_julia_function(MyList(1, 2, 3))\r\n;  @ REPL[6]:1 within `a_regular_julia_function`\r\n; Function Attrs: uwtable\r\ndefine i64 @julia_a_regular_julia_function_1290({ {}* }* nocapture nonnull readonly align 8 dereferenceable(8) %0) #0 {\r\ntop:\r\n    %1 = bitcast { {}* }* %0 to { i8*, i64, i16, i16, i32 }**\r\n    %2 = load atomic { i8*, i64, i16, i16, i32 }*, { i8*, i64, i16, i16, i32 }** %1 unordered, align 8\r\n    %3 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %2, i64 0, i32 1\r\n    %4 = load i64, i64* %3, align 8\r\n    %5 = mul i64 %4, 3\r\n    %6 = add i64 %5, 5\r\n    %7 = mul i64 %6, %6\r\n  ret i64 %7\r\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"P.S: Concrete methods defined in interfaces lead to a famous abstraction called Mixin. See IPolygon type at Inheritances, and multiple inheritances.","category":"page"},{"location":"#Addressing-performance-issues-via-@typed_access","page":"Home","title":"Addressing performance issues via @typed_access","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Because of the compiler optimization, using methods or Python-style properties might cause inaccurate type inference, and affect performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For possible performance issues, we provide @typed_access  to automatically optimize all a.b operations in Julia-compatible semantics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@typed_access begin\r\n    instance1.method(instance2.property)\r\nend\r\n\r\n# <=>\r\n\r\nTyOOP.getproperty_typed(instance1, Val(:method))(\r\n    TyOOP.getproperty_typed(instance, Val(:property))\r\n)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@typed_access slows down dynamic calls，but removes overheads of static calls。For a.b，if the type of a is successfully inferred, then @typed_access a.b is strictly faster than a.b.","category":"page"}]
}
