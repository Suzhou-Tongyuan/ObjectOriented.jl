<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ObjectOriented.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://Suzhou-Tongyuan.github.io/ObjectOriented.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>ObjectOriented.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#OO-type-definition"><span>OO type definition</span></a></li><li><a class="tocitem" href="#Python-style-constructors"><span>Python-style constructors</span></a></li><li><a class="tocitem" href="#inheritance"><span>Inheritances and multiple inheritances</span></a></li><li><a class="tocitem" href="#Python-style-properties"><span>Python-style properties</span></a></li><li><a class="tocitem" href="#advanced_absmeths_and_absprops"><span>Advanced feature: Abstract methods, and abstract properties</span></a></li><li><a class="tocitem" href="#Advanced-feature:-Generics"><span>Advanced feature: Generics</span></a></li><li><a class="tocitem" href="#Advanced-feature:-Interfaces"><span>Advanced feature: Interfaces</span></a></li><li><a class="tocitem" href="#Addressing-performance-issues-via-@typed_access"><span>Addressing performance issues via <code>@typed_access</code></span></a></li></ul></li><li><a class="tocitem" href="cheat-sheet-en/">Cheat Sheet</a></li><li><a class="tocitem" href="how-to-translate-oop-into-julia/">Translating OOP into Idiomatic Julia</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Suzhou-Tongyuan/ObjectOriented.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ObjectOriented.jl"><a class="docs-heading-anchor" href="#ObjectOriented.jl">ObjectOriented.jl</a><a id="ObjectOriented.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ObjectOriented.jl" title="Permalink"></a></h1><p><a href="index-cn/">中文文档</a></p><p><a href="https://github.com/Suzhou-Tongyuan/ObjectOriented.jl">ObjectOriented.jl</a> provides relatively complete object-oriented programming support for Julia. This is mainly based on CPython&#39;s object-oriented programming, and adapted for Julia.</p><p>The feature list is given below:</p><table><tr><th style="text-align: center">feature</th><th style="text-align: center">support</th><th style="text-align: center">notes</th></tr><tr><td style="text-align: center">inheritance</td><td style="text-align: center">yes</td><td style="text-align: center">upcasts/downcasts are not supported</td></tr><tr><td style="text-align: center">overloaded constructors and methods</td><td style="text-align: center">yes</td><td style="text-align: center">based on multiple dispatch</td></tr><tr><td style="text-align: center">multiple inheritance</td><td style="text-align: center">yes</td><td style="text-align: center">MRO based on <a href="https://en.wikipedia.org/wiki/C3_linearization">C3</a></td></tr><tr><td style="text-align: center">Python-style properties</td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">default field values</td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">generics</td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: center">interfaces</td><td style="text-align: center">yes</td><td style="text-align: center">singleton struct types as base classes</td></tr><tr><td style="text-align: center">modifiers</td><td style="text-align: center">no</td><td style="text-align: center">just like Python</td></tr><tr><td style="text-align: center">static class methods</td><td style="text-align: center">no</td><td style="text-align: center">won&#39;t fix to avoid <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">type piracy</a></td></tr><tr><td style="text-align: center">metaclasses</td><td style="text-align: center">no</td><td style="text-align: center">won&#39;t fix in favour of macros</td></tr></table><p>Quick start through <a href="cheat-sheet-en/">ObjectOriented.jl Cheat Sheet</a>.</p><p>Note that we very much support the community idea &quot;do not do OOP in Julia&quot;.</p><p>We make this guide <strong><a href="how-to-translate-oop-into-julia/">Translating OOP into Idiomatic Julia</a></strong> to instruct users on how to translate OOP code into Julia, promising more concise, more extensible and more efficient code.</p><p>We even took the effort to design ObjectOriented.jl as what it is now: the usage of OOP can be confined to the code of committed OOP users, and through interface programming, code of OOP exports APIs in normal Julia to avoid the proliferation of inappropriate code outside.</p><p>For those familiar with the Julia programming style, ObjectOriented.jl&#39;s the interface programming and field inheritance may still help. For such professional Julia programmers, it is recommended to only define fields in OO types and not to define dot methods (<code>self.method()</code>).</p><h2 id="OO-type-definition"><a class="docs-heading-anchor" href="#OO-type-definition">OO type definition</a><a id="OO-type-definition-1"></a><a class="docs-heading-anchor-permalink" href="#OO-type-definition" title="Permalink"></a></h2><p>ObjectOriented.jl supports defining <code>class</code>es and <code>struct</code>s. A <code>class</code> definition starts with <code>@oodef mutable struct</code>, while a <code>struct</code> definition starts with <code>@oodef struct</code>.</p><pre><code class="language-julia hljs">using ObjectOriented
@oodef struct MyStruct
    a :: Int
    function new(a::Int)
        @mk begin
            a = a
        end
    end
    function f(self)
        self.a
    end
end

@oodef mutable struct MyClass
    a :: Int
    function new(a::Int)
        @mk begin
            a = a
        end
    end
    function f(self)
        self.a
    end
end</code></pre><p>As shown above, <code>function new(...)</code> is responsible for defining class/struct constructors.</p><p>We recommand using a <code>@mk begin ... end</code> block as the return value. In the block, you can specify zero or more <code>field_name = field_value</code> to initialize fields.</p><p>The behaviour when missing constructors:</p><ol><li>if the type is a <code>class</code> (mutable struct), all fields are not initialized, as well as all base instances.</li><li>if the type is a <code>struct</code>, using Julia&#39;s default constructor.</li></ol><p>Constructors can be overloaded.</p><p>For the struct types whose memory consumption is <code>0</code>, constructors can be omitted.</p><h3 id="Instance-methods"><a class="docs-heading-anchor" href="#Instance-methods">Instance methods</a><a id="Instance-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Instance-methods" title="Permalink"></a></h3><p>instance methods should start with <code>function method_name(class_instance, ...)</code>. The instance variable is recommended to be named <code>self</code> or <code>this</code>.</p><p>The above code in both <code>MyClass</code> and <code>MyStruct</code> implement a method <code>f</code>. The method can be invoked using the syntax <code>instance.f()</code>.</p><pre><code class="language-julia hljs">@oodef mutable struct MyClass
    a :: Int
    
    # ... this part is omitted

    function f(self)
        self.a
    end
end</code></pre><p>Instance methods support aribitrary Julia parameters, such as variadic parameters, keyword arguments, variadic keyword arguments, default positional arguments and default keyword arguments.</p><p>Besides, the instance methods support generic parameters, and can be overloaded.</p><p>(<strong>P.S</strong>) If you want to annotate the <code>self</code> parameter, it is recommended to use <code>self :: @like(MyClass)</code> instead of <code>self :: MyClass</code>. This is because the method might be invoked by the subclasses, while Julia does not support implicit conversions between types.</p><p>(<strong>P.P.S</strong>) What is <code>@like</code>? Given an OO type <code>Parent</code>, any subtype <code>Child</code> (also an OO type) inheriting <code>Parent</code> satisfies <code>Child &lt;: @like(Parent)</code> in Julia, where <code>&lt;:</code> is Julia&#39;s native subtyping operator. <code>Child &lt;: Parent</code> can only be <code>false</code> in Julia.</p><h3 id="Default-field-values"><a class="docs-heading-anchor" href="#Default-field-values">Default field values</a><a id="Default-field-values-1"></a><a class="docs-heading-anchor-permalink" href="#Default-field-values" title="Permalink"></a></h3><p>Using this feature, when defining a field for classes/structs, if a default value is provided, then the initialization for this field can be missing in the <code>@mk</code> block.</p><pre><code class="language-julia hljs">function get_default_field2()
    println(&quot;default field2!&quot;)
    return 30
end

@oodef struct MyType
    field1 :: DataType = MyType
    field2 :: Int = get_default_field2()

    function new()
        return @mk
    end

    function new(field2::Integer)
        return @mk field2 = field2
    end
end

julia&gt; MyType()
default field2!
MyType(MyType, 30)

julia&gt; MyType(50)
MyType(MyType, 50)</code></pre><p>Some points of the default field values:</p><ol><li>there is no performance overhead in using default field values.</li><li>when a field has been explicitly initialized in the <code>@mk</code> block, the expression of the default field value won&#39;t be evaluated.</li><li>unlike <code>Base.@kwdef</code>, default field values cannot reference each other.</li></ol><h2 id="Python-style-constructors"><a class="docs-heading-anchor" href="#Python-style-constructors">Python-style constructors</a><a id="Python-style-constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Python-style-constructors" title="Permalink"></a></h2><p>The traditional OO languages such Python/C++/Java/C# do not have native immutable types, so that the jobs of a constructor can be designed as follow:</p><ol><li>creating a new instance <code>self</code> of the type.</li><li>invoking a constructor function to initialize the <code>self</code> instance. Side effects are introduced.</li></ol><p>ObjectOriented.jl can support such style for classes (<code>mutable struct</code>s), but it is not our best practice.</p><p>Example:</p><pre><code class="language-julia hljs">@oodef mutable struct MySubclass &lt;: {MySuperclass1, MySuperclass2}
    field1
    function new()
        self = @mk
        # init fields
        self.field1 = 1
        # remember to return self
        return self
    end</code></pre><h2 id="inheritance"><a class="docs-heading-anchor" href="#inheritance">Inheritances and multiple inheritances</a><a id="inheritance-1"></a><a class="docs-heading-anchor-permalink" href="#inheritance" title="Permalink"></a></h2><p>Here is a simple example of class inheritance.</p><p>We firstly define two structs using <code>@oodef</code>:</p><pre><code class="language-julia hljs">@oodef struct A
    a :: Int
end

@oodef struct B
    b :: Int
end</code></pre><p>Then, we define a type <code>C</code> to inherit <code>A</code> and <code>B</code>:</p><pre><code class="language-julia hljs">@oodef struct C &lt;: {A, B}
    c :: String
    function new(a::Int, b::Int, c::String = &quot;somestring&quot;)
        @mk begin
            A(a), B(b)
            c = c
        end
    end
end

c = C(1, 2)
@assert c.a === 1
@assert c.b === 2</code></pre><p>As can be seen, in the <code>@mk</code> block, we use <code>Base1(arg1, arg2), Base2(arg1, arg2)</code> to call the base classe constructors, which corresponds to <code>BaseType.__init__(self, arg1, arg2)</code> in Python.</p><p>A struct/class can inherit multiple base classes/structs. When name collision happens, we use C3 linearization algorithm to decide which one is to select. We use a variant of C3 to allow more flexible mixin uses.</p><p>The following example introduces mixin which is a common use of (multiple) inheritances:</p><p>We define a base class <code>IPolygon</code> which might have subclasses <code>Square</code>, <code>Rectangle</code>, <code>Triangle</code> or even general polygons. Despite the differences between these possible subclasses, a standard algorithm to compute perimeters is shared: sum up the lengths of all the edges.</p><pre><code class="language-julia hljs">using ObjectOriented

const Point = Tuple{Float64, Float64}
function distance(source::Point, destination::Point)
    sqrt(
        (destination[1] - source[1]) ^ 2 +
        (destination[2] - source[2]) ^ 2)
end

@oodef struct IPolygon
    # abstract method
    function get_edges end

    # mixin method
    function get_perimeter(self)
        s = 0.0
        vs = self.get_edges() :: AbstractVector{Point}
        if length(vs) &lt;= 1
            0.0
        end
        last = vs[1] :: Point
        for i = 2:length(vs)
            s += distance(vs[i], last)
            last = vs[i]
        end
        s += distance(vs[end], vs[1])
        return s
    end
end</code></pre><p>Leveraging the above <code>IPolygon</code>, we can define subclasses, reusing the <code>get_perimeter</code> method.</p><p>For instance, <code>Rectangle</code>：</p><pre><code class="language-julia hljs">@oodef struct Rectangle &lt;: IPolygon
    width :: Float64
    height :: Float64
    center :: Point

    function new(width::Float64, height::Float64, center::Point)
        @mk begin
            width = width
            height = height
            center = center
        end
    end

    function get_edges(self)
        x0 = self.center[1]
        y0 = self.center[2]
        h = self.height / 2
        w = self.width / 2
        Point[
            (x0 - w, y0 - h),
            (x0 - w, y0 + h),
            (x0 + w, y0 + h),
            (x0 + w, y0 - h)
        ]
    end

    # for very special subclasses, we can overwrite
    # &#39;get_perimeter&#39; to have a faster version:
    # function get_perimeter(self) ... end
end

rect = Rectangle(3.0, 2.0, (5.0, 2.0))
@assert rect.get_perimeter() == 10.0</code></pre><p>P.S: OO types shall only inherit from OO types defined using ObjectOriented.jl.</p><h2 id="Python-style-properties"><a class="docs-heading-anchor" href="#Python-style-properties">Python-style properties</a><a id="Python-style-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Python-style-properties" title="Permalink"></a></h2><p>In Java, the getter functions <code>get_xxx</code> and setter functions <code>set_xxx</code> are used to encapsulate the implementation details and export more stable APIs.</p><p>The syntactic redundancies involved above can be adddressed by a syntatic sugar, which is named &quot;properties&quot; by many languages such as Python.</p><p>ObjectOriented.jl supports so-called &quot;properties&quot;, in the following apprach:</p><pre><code class="language-julia hljs">@oodef struct DemoProp
    @property(value) do
        get = self -&gt; 100
        set = (self, value) -&gt; println(&quot;setting $value&quot;)
    end
end

println(DemoProp().value) # =&gt; 100
DemoProp().value = 200 # =&gt; setting 200</code></pre><p>A more practical example is given below:</p><pre><code class="language-julia hljs">@oodef mutable struct Square
    side :: Float64
    function new(side::Number)
        @mk begin
            side = side # support auto cast
        end
    end

    @property(area) do
        get = self -&gt; self.side ^ 2
        set = function (self, value)
            self.side = sqrt(value)
        end
    end
end

square = Square(5) # =&gt; Square(5.0)
square.area # =&gt; 25.0
square.area = 16 # =&gt; 16
square.side # =&gt; 4.0</code></pre><p>As can be seen, the side length of the square changes accordingly as the area gets changed.</p><h2 id="advanced_absmeths_and_absprops"><a class="docs-heading-anchor" href="#advanced_absmeths_and_absprops">Advanced feature: Abstract methods, and abstract properties</a><a id="advanced_absmeths_and_absprops-1"></a><a class="docs-heading-anchor-permalink" href="#advanced_absmeths_and_absprops" title="Permalink"></a></h2><pre><code class="language-julia hljs">@oodef struct AbstractSizedContainer{ElementType}

    # abstract method
    function contains end


    # abstract property with only getter
    @property(length) do
        get
    end
end

# print not implemented methods (including properties)
ObjectOriented.check_abstract(AbstractSizedContainer)
# =&gt;
# Dict{PropertyName, ObjectOriented.CompileTime.PropertyDefinition} with 2 entries:
#  contains (getter) =&gt; PropertyDefinition(:contains, missing, AbstractSizedContainer, MethodKind)
#  length (getter)   =&gt; PropertyDefinition(:length, missing, AbstractSizedContainer, GetterPropertyKind)

@oodef struct MyNumSet{E &lt;: Number} &lt;: AbstractSizedContainer{E}
    inner :: Set{E}
    function new(args::E...)
        @mk begin
            inner = Set{E}(args)
        end
    end

    # if no annotations for &#39;self&#39;,
    # annotations and type parameters can be added like:
    # &#39;function contains(self :: @like(MySet{E}), e::E) where E&#39;
    function contains(self, e::E)
        return e in self.inner
    end

    @property(length) do
        get = self -&gt; length(self.inner)
    end
end

my_set = MySet(1, 2, 3)
my_set.length # =&gt; 3
my_set.contains(2) # =&gt; true</code></pre><h2 id="Advanced-feature:-Generics"><a class="docs-heading-anchor" href="#Advanced-feature:-Generics">Advanced feature: Generics</a><a id="Advanced-feature:-Generics-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-feature:-Generics" title="Permalink"></a></h2><p>Generics are pervasive, and in practice very common in data structures.</p><p>At <a href="#advanced_absmeths_and_absprops">Advanced features：Abstract methods, and abstract properties</a>, we have introduced <code>AbstractSizedContainer</code>. It has a generic type parameter <code>ElementType</code>.</p><pre><code class="language-julia hljs">@oodef struct AbstractSizedContainer{ElementType}
    # (self, ::ElementType) -&gt; Bool
    function contains end
    @property(length) do
        get
    end
end</code></pre><p>Although we do not use <code>ElementType</code> in the above example, it is useful if we need to specify a container&#39;s element type.</p><pre><code class="language-julia hljs"># containers of only numbers
@oodef struct AbstactNumberContainer{ElementType &lt;: Number}
    ...
end

@oodef struct Optional{T}
    value :: Union{Nothing, Some{T}}
end</code></pre><h3 id="Advanced-feature:-Explicit-generic-type-parameters"><a class="docs-heading-anchor" href="#Advanced-feature:-Explicit-generic-type-parameters">Advanced feature: Explicit generic type parameters</a><a id="Advanced-feature:-Explicit-generic-type-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-feature:-Explicit-generic-type-parameters" title="Permalink"></a></h3><p>The following code shows a special case where the constructor <code>new</code> cannot infer the generic type parameter <code>A</code> from the arguments:</p><pre><code class="language-julia hljs">@oodef struct MyGenType{A}
    a :: Int
    function new(a::Int)
        new{A}(a)
    end
end</code></pre><p>In this case, we can explicitly specify the generic type parameters to construct instances:</p><pre><code class="language-julia hljs">my_gen_type = MyGenType{String}(1)
my_gen_type = MyGenType{Number}(1)
my_gen_type = MyGenType{Vector{Int}}(1)</code></pre><h2 id="Advanced-feature:-Interfaces"><a class="docs-heading-anchor" href="#Advanced-feature:-Interfaces">Advanced feature: Interfaces</a><a id="Advanced-feature:-Interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-feature:-Interfaces" title="Permalink"></a></h2><p>ObjectOriented.jl supports interface programming. Use <code>@oodef struct</code> to define a struct which has no fields, and add some abstract/mixin methods to it, in this way we achieve interface programming.</p><p>Despite the ease of connecting with the real business logic, interfaces also helps to specify proper constraints in your code.</p><h3 id="@like(ootype)"><a class="docs-heading-anchor" href="#@like(ootype)"><code>@like(ootype)</code></a><a id="@like(ootype)-1"></a><a class="docs-heading-anchor-permalink" href="#@like(ootype)" title="Permalink"></a></h3><p><code>@like</code> transforms a concrete OO type into a special abstract type.</p><pre><code class="language-julia hljs">julia&gt; @like(HasLength)
Object{&gt;:var&quot;HasLength::trait&quot;}</code></pre><p>In Julia&#39;s type system, no concrete type can be inherited. A direct implication is that Julia&#39;s multiple dispatch does not accept a subtype instance if the parameter is annotated a base type. </p><pre><code class="language-julia hljs">@oodef struct SuperC end
@oodef struct SubC &lt;: SuperC end
function f(::SuperC) end
f(SuperC()) # ok
f(SubC())   # err</code></pre><p><code>@like(ootype)</code> addresses this. A function parameter <code>@like(HasLength)</code> accepts instances of any type that is a subtype of <code>HasLength</code>.</p><pre><code class="language-julia hljs">@oodef struct SuperC end
@oodef struct SubC &lt;: SuperC end
function f(::@like(SuperC)) end
f(SuperC()) # ok
f(SubC())   # ok!</code></pre><h3 id="Examples,-and-zero-cost-abstraction"><a class="docs-heading-anchor" href="#Examples,-and-zero-cost-abstraction">Examples, and zero-cost abstraction</a><a id="Examples,-and-zero-cost-abstraction-1"></a><a class="docs-heading-anchor-permalink" href="#Examples,-and-zero-cost-abstraction" title="Permalink"></a></h3><p>The following code based on the interface <code>HasLength</code> defines a regular Julia function <code>a_regular_julia_function</code>:</p><pre><code class="language-julia hljs">@oodef struct HasLength
    function get_length end
end

function a_regular_julia_function(o :: @like(HasLength))
    function some_random_logic(i::Integer)
        (i * 3 + 5) ^ 2
    end
    some_random_logic(o.get_length())
end</code></pre><p>Now, we define a substruct <code>MyList</code> that inherits from <code>HasLength</code>, as the user wrapper of Julia&#39;s builtin <code>Vector</code> type:</p><pre><code class="language-julia hljs">@oodef struct MyList{T} &lt;: HasLength
    inner :: Vector{T}

    function new(elts::T...)
        @mk begin
            inner = collect(T, elts)
        end
    end

    function get_length(self)
        length(self.inner)
    end
end

a_regular_julia_function(MyList(1, 2, 3)) # 196
a_regular_julia_function([1]) # error</code></pre><p>We can see that only the OO type that implements <code>HasLength</code> is accepted by <code>a_regular_julia_function</code>.</p><p>Additionally, we point out that such interface abstraction itself does not introduce any dynamic dispatch. If your code contains only static dispatch, the abstraction is zero-cost.</p><pre><code class="language-julia hljs">@code_typed a_regular_julia_function(MyList(1, 2, 3))
CodeInfo(
1 ─ %1 = (getfield)(o, :inner)::Vector{Int64}
│   %2 = Base.arraylen(%1)::Int64
│   %3 = Base.mul_int(%2, 3)::Int64
│   %4 = Base.add_int(%3, 5)::Int64
│   %5 = Base.mul_int(%4, %4)::Int64
└──      return %5
) =&gt; Int64

julia&gt; @code_llvm a_regular_julia_function(MyList(1, 2, 3))
;  @ REPL[6]:1 within `a_regular_julia_function`
; Function Attrs: uwtable
define i64 @julia_a_regular_julia_function_1290({ {}* }* nocapture nonnull readonly align 8 dereferenceable(8) %0) #0 {
top:
    %1 = bitcast { {}* }* %0 to { i8*, i64, i16, i16, i32 }**
    %2 = load atomic { i8*, i64, i16, i16, i32 }*, { i8*, i64, i16, i16, i32 }** %1 unordered, align 8
    %3 = getelementptr inbounds { i8*, i64, i16, i16, i32 }, { i8*, i64, i16, i16, i32 }* %2, i64 0, i32 1
    %4 = load i64, i64* %3, align 8
    %5 = mul i64 %4, 3
    %6 = add i64 %5, 5
    %7 = mul i64 %6, %6
  ret i64 %7
}</code></pre><p>P.S: Concrete methods defined in interfaces lead to a famous abstraction called Mixin. See <code>IPolygon</code> type at <a href="@id inheritance">Inheritances, and multiple inheritances</a>.</p><h2 id="Addressing-performance-issues-via-@typed_access"><a class="docs-heading-anchor" href="#Addressing-performance-issues-via-@typed_access">Addressing performance issues via <code>@typed_access</code></a><a id="Addressing-performance-issues-via-@typed_access-1"></a><a class="docs-heading-anchor-permalink" href="#Addressing-performance-issues-via-@typed_access" title="Permalink"></a></h2><p>Because of the compiler optimization, using methods or Python-style properties might cause inaccurate type inference, and affect performance.</p><p>For possible performance issues, we provide <code>@typed_access</code>  to automatically optimize all <code>a.b</code> operations in Julia-compatible semantics.</p><pre><code class="language-julia hljs">@typed_access begin
    instance1.method(instance2.property)
end

# &lt;=&gt;

ObjectOriented.getproperty_typed(instance1, Val(:method))(
    ObjectOriented.getproperty_typed(instance, Val(:property))
)</code></pre><p><code>@typed_access</code> slows down dynamic calls，but removes overheads of static calls。For <code>a.b</code>，if the type of <code>a</code> is successfully inferred, then <code>@typed_access a.b</code> is strictly faster than <code>a.b</code>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="cheat-sheet-en/">Cheat Sheet »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Monday 25 July 2022 03:07">Monday 25 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
