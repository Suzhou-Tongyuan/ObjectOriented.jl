<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · TyOOP.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Suzhou-Tongyuan.github.io/TyOOP.jl/cheat-sheet-cn/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TyOOP.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../cheat-sheet-en/">Cheat Sheet</a></li><li><a class="tocitem" href="../how-to-translate-oop-into-julia/">Translating OOP into Idiomatic Julia</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Suzhou-Tongyuan/TyOOP.jl/blob/main/docs/src/cheat-sheet-cn.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="TyOOP-Cheat-Sheet"><a class="docs-heading-anchor" href="#TyOOP-Cheat-Sheet">TyOOP Cheat Sheet</a><a id="TyOOP-Cheat-Sheet-1"></a><a class="docs-heading-anchor-permalink" href="#TyOOP-Cheat-Sheet" title="Permalink"></a></h2><p>TyOOP为Julia提供面向对象编程的功能，支持多继承、点操作符取成员、Python风格的properties以及接口编程。</p><h3 id=".-类型定义"><a class="docs-heading-anchor" href="#.-类型定义">1. 类型定义</a><a id=".-类型定义-1"></a><a class="docs-heading-anchor-permalink" href="#.-类型定义" title="Permalink"></a></h3><p>定义不可变的OO结构体。</p><pre><code class="language-julia hljs">@oodef struct ImmutableData
    x :: Int
    y :: Int

    function new(x::Int, y::Int) 
        @mk begin
            x = x
            y = y
        end
    end
end

d = ImmutableData(1, 2)
x = d.x</code></pre><p>其中，<code>new</code>是构造器函数。构造器和方法都可以重载。</p><p><code>@mk</code>语句块产生当前类型的实例，在随后的语句块中，形如<code>a = b</code>是设置字段，形如<code>BaseClass(arg1, arg2)</code>是基类初始化。</p><p>定义可变的OO结构体（class）。</p><pre><code class="language-julia hljs">@oodef mutable struct MutableData
    x :: Int
    y :: Int

    function new(x::Int, y::Int) 
        @mk begin
            x = x
            y = y
        end
    end
end

mt = MutableData(1, 2)
mt.x += 1</code></pre><h4 id="默认字段"><a class="docs-heading-anchor" href="#默认字段">默认字段</a><a id="默认字段-1"></a><a class="docs-heading-anchor-permalink" href="#默认字段" title="Permalink"></a></h4><p>TyOOP支持默认字段。</p><p>在为类型定义一个字段时，如果为这个字段指定默认值，那么<code>@mk</code>宏允许缺省该字段的初始化。注意，如果不定义<code>new</code>函数并使用<code>@mk</code>宏，默认字段将无效。</p><pre><code class="language-julia hljs">function get_default_field2()
    println(&quot;default field2!&quot;)
    return 30
end

@oodef struct MyType
    field1 :: DataType = MyType
    field2 :: Int = get_default_field2()

    function new()
        return @mk
    end

    function new(field2::Integer)
        return @mk field2 = field2
    end
end

julia&gt; MyType()
default field2!
MyType(MyType, 30)

julia&gt; MyType(50)
MyType(MyType, 50)</code></pre><p>关于默认字段的注意点：</p><ol><li>默认字段没有性能开销。</li><li>在<code>@mk</code>块显式指定字段初始化时，默认字段的求值表达式不会被执行。</li><li>与<code>Base.@kwdef</code>不同，默认字段的求值表达式无法访问其他字段。</li></ol><h3 id=".-继承"><a class="docs-heading-anchor" href="#.-继承">2. 继承</a><a id=".-继承-1"></a><a class="docs-heading-anchor-permalink" href="#.-继承" title="Permalink"></a></h3><pre><code class="language-julia hljs">@oodef mutable struct Animal
    name :: String
    function new(theName::String)
        @mk begin
            name = theName
        end
    end

    function move(self, distanceInMeters::Number = 0)
        println(&quot;$(self.name) moved $(distanceInMeters)&quot;)
    end
end

@oodef mutable struct Snake &lt;: Animal
    function new(theName::String)
        @mk begin
            Animal(theName) # 初始化基类
        end
    end

    function snake_check(self)
        println(&quot;Calling a snake specific method!&quot;)
    end
end

sam = Snake(&quot;Sammy the Python&quot;)
sam.move()
# Sammy the Python moved 0
sam.snake_check()
# Calling a snake specific method!</code></pre><p>此外，以下需要非常注意！</p><pre><code class="language-julia hljs">Snake &lt;: Animal # false
Snake(&quot;xxx&quot;) isa Animal # false</code></pre><p>记住，Julia原生类型系统并不理解两个class的子类型关系！详见<a href="@ref interface_polymorphism">基于接口的多态抽象</a>。</p><p>你应该使用下列方法测试继承关系：</p><pre><code class="language-julia hljs">issubclass(Snake, Animal) # true
isinstance(Snake(&quot;xxx&quot;), Animal) # true
Snake(&quot;xxx&quot;) isa @like(Animal) # true</code></pre><h3 id=".-Python-style-properties"><a class="docs-heading-anchor" href="#.-Python-style-properties">4. Python-style properties</a><a id=".-Python-style-properties-1"></a><a class="docs-heading-anchor-permalink" href="#.-Python-style-properties" title="Permalink"></a></h3><pre><code class="language-julia hljs">@oodef mutable struct Square
    side :: Float64

    @property(area) do
        get = self -&gt; self.side ^ 2
        set = (self, value::Number) -&gt; self.side = convert(Float64, sqrt(value))
    end
end

square = Square()
square.side = 10
# call getter
square.area # 100.0

# call setter
square.area = 25
square.side # 5.0</code></pre><h3 id=".-接口"><a class="docs-heading-anchor" href="#.-接口">5. 接口</a><a id=".-接口-1"></a><a class="docs-heading-anchor-permalink" href="#.-接口" title="Permalink"></a></h3><p>接口类型，是大小为0(<code>sizeof(t) == 0</code>)的<strong>不可变</strong>OO类型。</p><p>接口类型的构造器是自动生成的，但也可以手动定义。</p><p>下面的<code>HasLength</code>是接口类型。</p><pre><code class="language-julia hljs">@oodef struct HasLength
    @property(len) do
        get  #= 抽象property: len =#
    end
end

@oodef struct Fillable
    function fill! end # 空函数表示抽象方法

    # 定义一个抽象的setter, 可以为全体元素赋值
    @property(allvalue) do
        set
    end
end

@oodef struct MyVector{T} &lt;: {HasLength, Fillable}  # 多继承
    xs :: Vector{T}
    function new(xs::Vector{T})
        @mk begin
            xs = xs
        end
    end
end

check_abstract(MyVector)
# Dict{PropertyName, TyOOP.CompileTime.PropertyDefinition} with 3 entries:
#   fill! (getter)    =&gt; PropertyDefinition(:fill!, missing, :((Main).Fillable), MethodKind)
#   len (getter)      =&gt; PropertyDefinition(:len, missing, :((Main).HasLength), GetterPropertyKind)
#   allvalue (setter) =&gt; PropertyDefinition(:allvalue, missing, :((Main).Fillable), SetterPropertyKind)</code></pre><p><code>check_abstract(MyVector)</code>不为空，表示<code>MyVector</code>是抽象类型，否则需要实现相应属性或方法<code>len</code>, <code>fill!</code>和<code>allvalue</code>：</p><pre><code class="language-julia hljs">@oodef struct MyVector{T} &lt;: {HasLength, Fillable}  # 多继承
    # 旧代码
    xs :: Vector{T}
    function new(xs::Vector{T})
        @mk begin
            xs = xs
        end
    end

    # 新增代码
    @property(len) do
        get = self -&gt; length(self.xs)
    end

    @property(allvalue) do
        set = (self, value::T) -&gt; fill!(self.xs, value)
    end

    function fill!(self, v::T)
        self.allvalue = v
    end
end

vec = MyVector([1, 2, 3])
vec.allvalue = 4
vec
# MyVector{Int64}([4, 4, 4], HasLength(), Fillable())
vec.len
# 3
vec.fill!(10)
vec
# MyVector{Int64}([10, 10, 10], HasLength(), Fillable())</code></pre><p>此外，接口最重要的目的是基于接口的多态抽象。见下文<a href="@ref interface_polymorphism_cn">基于接口的多态抽象</a>。</p><h3 id=".-多继承"><a class="docs-heading-anchor" href="#.-多继承">6. 多继承</a><a id=".-多继承-1"></a><a class="docs-heading-anchor-permalink" href="#.-多继承" title="Permalink"></a></h3><p>MRO(方法解析顺序)使用Python C3算法，所以多继承行为与Python基本一样。主要差异是不严格要求mixin多继承的顺序。</p><pre><code class="language-julia hljs">@oodef struct A
    function calla(self) &quot;A&quot; end
    function call(self) &quot;A&quot; end
end

@oodef struct B &lt;: A
    function callb(self) &quot;B&quot; end
    function call(self) &quot;B&quot; end
end

@oodef mutable struct C &lt;: A
    function callc(self) &quot;C&quot; end
    function call(self) &quot;C&quot; end
end

@oodef struct D &lt;: {A, C, B}
    function new()
        @mk begin
            A() # 可省略，因为A是接口类型
            B() # 可省略，因为B是接口类型
            C() # 不可省略，因为C是可变类型
            # 基类初始化可写成一行: A(), B(), C()
        end
    end
end

d = D()
d.calla() # A
d.callb() # B
d.callc() # C
d.call() # C
[x[1] for x in ootype_mro(typeof(d))]
# 4-element Vector{DataType}:
#  D
#  C
#  B
#  A</code></pre><h3 id=".-[基于接口的多态抽象](@id-interface_polymorphism)"><a class="docs-heading-anchor" href="#.-[基于接口的多态抽象](@id-interface_polymorphism)">7. <a href="@id interface_polymorphism">基于接口的多态抽象</a></a><a id=".-[基于接口的多态抽象](@id-interface_polymorphism)-1"></a><a class="docs-heading-anchor-permalink" href="#.-[基于接口的多态抽象](@id-interface_polymorphism)" title="Permalink"></a></h3><p>下面例子给出一个容易犯错的情况：</p><pre><code class="language-julia hljs">@oodef struct A end
@oodef struct B &lt;: A end
myapi(x :: A) = println(&quot;do something!&quot;)

myapi(A())
# do something!

myapi(B())
# ERROR: MethodError: no method matching myapi(::B)</code></pre><p>记住：Julia原生类型系统并不理解两个class的子类型关系！</p><p>如果希望Julia函数<code>myapi</code>的参数只接受A或A的子类型，应该这样实现：</p><pre><code class="language-julia hljs">myapi(x :: @like(A)) = println(&quot;do something!&quot;)

myapi(B())
# do something!

myapi([])
# ERROR: MethodError: no method matching myapi(::Vector{Any})</code></pre><h3 id=".-一个机器学习的OOP实例"><a class="docs-heading-anchor" href="#.-一个机器学习的OOP实例">8. 一个机器学习的OOP实例</a><a id=".-一个机器学习的OOP实例-1"></a><a class="docs-heading-anchor-permalink" href="#.-一个机器学习的OOP实例" title="Permalink"></a></h3><p>在下面这份代码里，我们实现一个使用最小二乘法训练的机器学习模型，并让其支持Julia中ScikitLearn的接口 (ScikitLearnBase.jl)。通过下面代码，用户可以像使用一般ScikitLearn.jl的模型一样来调用这个模型，更可以在MLJ机器学习框架中使用这个模型，而不必关心该模型由面向对象还是多重分派实现。</p><pre><code class="language-julia hljs">using TyOOP

@oodef struct AbstractMLModel{X, Y}
    function fit! end
    function predict end
end

using LsqFit

@oodef mutable struct LsqModel{M&lt;:Function} &lt;: AbstractMLModel{Vector{Float64},Vector{Float64}}
    model::M  # 一个函数，代表模型的公式
    param::Vector{Float64}

    function new(m::M, init_param::Vector{Float64})
        @mk begin
            model = m
            param = init_param
        end
    end

    function fit!(self, X::Vector{Float64}, y::Vector{Float64})
        fit = curve_fit(self.model, X, y, self.param)
        self.param = fit.param
        self
    end

    function predict(self, x::Float64)
        self.predict([x])
    end

    function predict(self, X::Vector{Float64})
        return self.model(X, self.param)
    end
end

# 例子来自 https://github.com/JuliaNLSolvers/LsqFit.jl

@. model(x, p) = p[1] * exp(-x * p[2])
clf = LsqModel(model, [0.5, 0.5])
ptrue = [1.0, 2.0]
xdata = collect(range(0, stop = 10, length = 20));
ydata = collect(model(xdata, ptrue) + 0.01 * randn(length(xdata)));

clf.fit!(xdata, ydata) # 训练模型
clf.predict(xdata)  # 预测模型
clf.param # 查看模型参数

# ScikitLearnBase提供了fit!和predict两个接口函数。
# 我们将TyOOP的接口(@like(...))和Julia接口对接。

using ScikitLearnBase
ScikitLearnBase.is_classifier(::@like(AbstractMLModel)) = true
ScikitLearnBase.fit!(clf::@like(AbstractMLModel{X, Y}), x::X, y::Y) where {X, Y} = clf.fit!(x, y)
ScikitLearnBase.predict(clf::@like(AbstractMLModel{X}), x::X) where X = clf.predict(x)

ScikitLearnBase.fit!(clf, xdata, ydata)
ScikitLearnBase.predict(clf, xdata)</code></pre><h3 id=".-性能问题"><a class="docs-heading-anchor" href="#.-性能问题">9. 性能问题</a><a id=".-性能问题-1"></a><a class="docs-heading-anchor-permalink" href="#.-性能问题" title="Permalink"></a></h3><p>TyOOP生成的代码本身不引入开销，但由于递归调用点操作符运算 (<code>Base.getproperty(...)</code>) 的类型推断问题 (例如<a href="https://discourse.julialang.org/t/type-inference-problem-with-getproperty/54585/2?u=thautwarm">这个例子</a>)，尽管大多数时候TyOOP编译出的机器码非常高效，但返回类型却忽然变成<code>Any</code>或某种<code>Union</code>类型。</p><p>这可能带来性能问题。出现该问题的情况是有限的，问题场合如下：</p><ol><li>使用Python风格的property</li><li>在method里访问另一个成员，该成员再次递归调用点操作符</li></ol><p>解决方案也很简单，使用<code>@typed_access</code>标注可能出现性能问题的代码即可。</p><pre><code class="language-julia hljs">@typed_access my_instance.method()
@typed_access my_instance.property</code></pre><p>注意：上述代码中请保证<code>my_instance</code>类型已知。如果<code>@typed_access</code>标注的代码存在动态类型或类型不稳定，可能导致更严重的性能问题。</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Thursday 7 July 2022 13:53">Thursday 7 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
